#include <string>
#include <vector>
#include <cstdio>
#include <cstdlib>

#include <iostream>
#include <corecrt_io.h>

#include "./include/gxr_sraw2bgr.h"
#include "./include/AWB_handle.h"
#include "./include/aeHandle.h"
#include "atfHandle.h"
#include <thread>
#include "../comData/comData.h"

using namespace std;

static int height = 1744; 
static int width = 2328; 
static int const lsc_height = 13;
static int const lsc_width = 17;
static float lsctable[lsc_height * lsc_width * 4];
static unsigned short gmtablex[257] = { 0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816,820,824,828,832,836,840,844,848,852,856,860,864,868,872,876,880,884,888,892,896,900,904,908,912,916,920,924,928,932,936,940,944,948,952,956,960,964,968,972,976,980,984,988,992,996,1000,1004,1008,1012,1016,1020,1023 };
static unsigned short gmtabley[257] = { 0, 22, 43, 60, 74, 86, 96, 106, 114, 123, 130, 137, 144, 153, 167, 180, 192, 204, 214, 227, 240, 252, 264, 275, 286, 297, 307, 317, 327, 336, 345, 354, 363, 371, 380, 388, 396, 403, 411, 418, 426, 433, 440, 447, 454, 461, 467, 474, 480, 487, 493, 499, 505, 511, 517, 523, 529, 534, 540, 546, 551, 557, 562, 567, 573, 578, 583, 588, 593, 598, 603, 608, 613, 618, 623, 627, 632, 637, 642, 646, 651, 655, 660, 664, 669, 673, 677, 682, 686, 690, 695, 699, 703, 707, 711, 715, 719, 723, 727, 731, 735, 739, 743, 747, 751, 755, 759, 762, 766, 770, 774, 777, 781, 785, 788, 792, 796, 799, 803, 806, 809, 811, 814, 816, 819, 822, 824, 827, 829, 832, 834, 837, 839, 841, 844, 846, 849, 851, 854, 856, 858, 861, 863, 865, 868, 870, 872, 875, 877, 879, 881, 884, 886, 888, 890, 893, 895, 897, 899, 901, 904, 906, 908, 910, 912, 914, 917, 919, 921, 923, 925, 927, 929, 931, 933, 935, 938, 940, 942, 944, 946, 948, 950, 952, 954, 956, 958, 960, 962, 964, 966, 968, 970, 972, 973, 975, 977, 979, 981, 983, 985, 987, 989, 991, 993, 994, 994, 995, 996, 996, 997, 997, 998, 999, 999, 1000, 1000, 1001, 1001, 1002, 1003, 1003, 1004, 1004, 1005, 1006, 1006, 1007, 1007, 1008, 1008, 1009, 1010, 1010, 1011, 1011, 1012, 1012, 1013, 1014, 1014, 1015, 1015, 1016, 1016, 1017, 1018, 1018, 1019, 1019, 1020, 1020, 1021, 1021, 1022, 1023, 1023 };
static unsigned short* input_buffer; // ����ͼ bayer unpack
static unsigned char* output_buffer; // ���ͼ bgr pack

static bool ppmWrite(char const* name, unsigned char* src, int rows, int cols)
{
	unsigned char* rgb = (unsigned char*)malloc(rows * cols * 3);
	size_t total = rows * cols * 3;
	for (size_t i = 0; i < total; i += 3)
	{
		rgb[i] = src[i + 2];
		rgb[i + 1] = src[i + 1];
		rgb[i + 2] = src[i];
	}
	char header[256];
	int szhead = snprintf(header, sizeof(header),
		"P%c\n# Generated by GXR xlluo\n%d %d\n255\n",
		static_cast<char>('5' + 1), cols, rows);
	FILE* fid = fopen(name, "wb");
	fwrite(header, 1, szhead, fid);
	fwrite(rgb, 1, rows * cols * 3, fid);
	fclose(fid);
	free(rgb);
	return true;
}

int saveAsFile(const char* filePath, int* p, int lens)
{
	FILE* fp = fopen(filePath, "w+");
	if (!fp)
	{
		return 1;
	}
	for (int i = 0; i < lens; i++)
	{
		//fprintf(fp, "%#x\n", p[i]);
		fprintf(fp, "%d\n", p[i] * 4);
	}
	//fwrite(p, sizeof(uint16_t), lens, fp);
	fclose(fp);
	return 0;
}

int main(int argc, char** argv)
{
	/* buffer */
	input_buffer = (unsigned short*)malloc(height * width * sizeof(unsigned short));
	output_buffer = (unsigned char*)malloc(height * width * 3 * sizeof(unsigned char));

	/* lens shading init */
	for (int i = 0; i < sizeof(lsctable) / sizeof(float); i++)
		lsctable[i] = 1.f;

	/* 算法句柄初始化 */
	printf("gxr_sraw2bgr version: %s\n", gxr_sraw2bgr_version().Version);
	gxr_sraw2bgr* raw2bgr_handle = new gxr_sraw2bgr;
	gxr_sraw2bgr_initialize(raw2bgr_handle);

	gxr_awbhd gxr_awb;
	gxr_aehd gxr_ae;
	gxr_atfhd gxr_atf;
	unsigned int ae_err = 0x00;
	unsigned int awb_err = _AL_AWBLIB_SUCCESS;
	unsigned int atf_err = 0x00;

	/* FS DATA COM INIT*/
	//HANDLE comHandle = INVALID_HANDLE_VALUE;//串口句柄    	

	////打开串口
	//const char* com = "COM7";
	//comHandle = OpenSerial(com, CBR_9600, 8, NOPARITY, ONESTOPBIT);
	//if (INVALID_HANDLE_VALUE == comHandle) {
	//	LOGE("OpenSerial COM7 fail!\r\n");
	//	//return -1;
	//}
	//LOGD("Open COM7 Successfully!\r\n");
	// 
	// init gxr_atf fs
	memset(&gxr_atf.fs_result, 0, sizeof(FS_result));

	/*update com data*/
	//thread_com(comHandle, &gxr_atf.fs_result);
	
	//FS_result COM_data;
	//thread_com(comHandle, &COM_data, &gxr_atf.fs_result);

	//std::shared_future<void> fret = std::async([&] {
	//	comData(comHandle, &gxr_atf.fs_result);
	//	});

	//std::thread t1([&] {
	//	comData(comHandle, &gxr_atf.fs_result);
	//	});
	//t1.join();

	/* AE算法初始化 */
	gxr_ae.min_iso = 100;   // scale 100
	gxr_ae.calib_b_gain = 1000;   // scale 1000
	gxr_ae.calib_g_gain = 1000;
	gxr_ae.calib_r_gain = 1000;
	gxr_ae.atf_mode = (enum ae_antiflicker_mode_t)0;
	// set AE enable
	gxr_ae.ae_enable = 1;
	gxr_ae.cameraId = 0;  //left:0; right:1

	ae_err = ae_initial(&gxr_ae);
	if (ae_err != 0x00) {
		printf("AE init error: %#x\r\n", ae_err);
		return ae_err;
	}

	/* AWB算法初始化 */
	gxr_awb.awb_set_para.para.awb_calib_data.calib_r_gain = 1000;
	gxr_awb.awb_set_para.para.awb_calib_data.calib_g_gain = 1000;
	gxr_awb.awb_set_para.para.awb_calib_data.calib_b_gain = 1000;
	awb_err = awb_initial(&gxr_awb);
	if (awb_err != _AL_AWBLIB_SUCCESS) {
		printf("INIT ERROR %x\r\n", (unsigned int)awb_err);
		return awb_err;
	}
	
	/* ATF init*/
	//get sensor info
	gxr_atf.line_time_ns = 6371;   //diffrent with sensors  similar as 1/fps/VST
	gxr_atf.sensor_height = height;
	gxr_atf.sensor_width = width;
	atf_err = atf_initial(&gxr_atf);
	if (atf_err != 0x00) {
		printf("AE init error: %#x\r\n", atf_err);
		return atf_err;
	}

	/* 参数初始化 */
	char verbose = 7;
	int rpat = 0;
	int depth = 10;
	int bpc = 0; 
	char wben = 1, expen = 1, atfen = 1; // 白平衡和曝光是否打开
	int awbsat = 255;
	int awb_blknumx = 32;
	int awb_blknumy = 32;
	vector<int> awbstats(awb_blknumx * awb_blknumy * 5);
	int aesat = 1023; 
	int ae_blknumx = 16;
	int ae_blknumy = 16;
	vector<int> aestats(ae_blknumx * ae_blknumy * 8);
	vector<int> histgram(256);
	int atf_roiheight = height;
	int atf_roiwidth = width;
	vector<int> atfstats(atf_roiheight);
	int top = 0, bottom = height, left = 0, right = width; 
	float wbgain[4] = { 1,1,1,1 }; // r gr gb b
	int blacklevel[4] = { 64, 64, 64, 64 }; // ��10bit
	float ccm[9] = { 1.568639f,-0.358657f,-0.209982f,-0.191115f,1.646191f,-0.455076f,0.070816f,-0.684568f,1.613751f }; // rgb
	float sensorgain = 1;
	float ispgain = 1;
	float adrcgain = 1;
	float shutter = 4000; // us
	float luxindex = 1;

	raw2bgr_handle->verbose = verbose;
	raw2bgr_handle->rpat = rpat;
	raw2bgr_handle->depth = depth;
	raw2bgr_handle->bpc = bpc;
	raw2bgr_handle->height = height;
	raw2bgr_handle->width = width;
	raw2bgr_handle->top = top;
	raw2bgr_handle->bottom = bottom;
	raw2bgr_handle->left = left;
	raw2bgr_handle->right = right;
	raw2bgr_handle->wben = wben;
	raw2bgr_handle->expen = expen;
	raw2bgr_handle->atfen = atfen;
	raw2bgr_handle->awbsat = awbsat;
	raw2bgr_handle->awb_blknumx = awb_blknumx;
	raw2bgr_handle->awb_blknumy = awb_blknumy;
	raw2bgr_handle->aesat = aesat;
	raw2bgr_handle->ae_blknumx = ae_blknumx;
	raw2bgr_handle->ae_blknumy = ae_blknumy;
	raw2bgr_handle->atf_roiheight = atf_roiheight;
	raw2bgr_handle->atf_roiwidth = atf_roiwidth;
	memcpy(raw2bgr_handle->blacklevel, blacklevel, sizeof(blacklevel));
	raw2bgr_handle->sensorgain = sensorgain;
	raw2bgr_handle->ispgain = ispgain;
	raw2bgr_handle->adrcgain = adrcgain;
	raw2bgr_handle->shutter = shutter;
	raw2bgr_handle->luxindex = luxindex;
	raw2bgr_handle->lsc_height = lsc_height;
	raw2bgr_handle->lsc_width = lsc_width;
	raw2bgr_handle->lsctable[0] = lsctable;
	raw2bgr_handle->lsctable[1] = lsctable + lsc_height * lsc_width;
	raw2bgr_handle->lsctable[2] = lsctable + lsc_height * lsc_width * 2;
	raw2bgr_handle->lsctable[3] = lsctable + lsc_height * lsc_width * 3;
	raw2bgr_handle->gmtablex = gmtablex;
	raw2bgr_handle->gmtabley = gmtabley;
	raw2bgr_handle->input = input_buffer;
	raw2bgr_handle->output = output_buffer;
	memcpy(raw2bgr_handle->wbgain, wbgain, sizeof(wbgain));
	memcpy(raw2bgr_handle->ccm, ccm, sizeof(ccm));

	//for save ae out, init keep with ini file
	float ae_sensor_gain = sensorgain;
	float ae_shutter = shutter;				 // us
	float ae_out_ispgain = ispgain;
	float ae_lux_result = luxindex;

	/* 跑一系列图 */
	int frame_num = 0;
	intptr_t hFile = 0;
	struct _finddata_t fileInfo;
	string pathName, fileName;
	//string path = "D:\\work\\ATF\\data\\simu\\100hz";
	//string path = "D:\\work\\ATF\\data\\simu\\50hz";
	//string path = "D:\\work\\ATF\\data\\Banding_100hz";
	string path = "D:\\work\\ATF\\data\\banding";
	//string path = "D:\\work\\ATF\\data\\scene2_8x";
	//string path = "D:\\work\\ATF\\data\\scene6_16x";
	//string path = "D:\\work\\ATF\\data\\scene3_8x";
	//string path = "D:\\work\\ATF\\data\\scene1_8x";
	//string path = "D:\\work\\ATF\\data\\0313\\Raw";
	//string path = "D:\\work\\ATF\\data\\0316\\Raw";
	//string path = "D:\\work\\ATF\\data\\0316\\crop\\Raw";

	//string path = "D:\\work\\PCMR\\Release\\output_test";

	string rawpath = path;
	hFile = _findfirst(pathName.assign(path).append("\\*.raw").c_str(), &fileInfo);
	if (hFile == -1) {
		std::cout << "there is no flie to read" << endl;
		//return 1;
		return ae_err;
	}
	int cnt_0 = 0;
	int cnt_50 = 0;
	int cnt_60 = 0;

	do
	//while (frame_num++ < 10)
	{

		fileName = rawpath + "\\" + fileInfo.name;

		//fileName = "D:\\work\\PCMR\\Release\\output_test\\0_unpack.raw";

		std::cout << "fileName: %s" << fileName << endl;
		//FILE* fid = fopen("0.raw", "rb");
		//FILE* fid = fopen("D:\\work\\AE\\data\\4l\\7ms_8x\\CAM1_[0]_[2328_1744]_[152110_0435]_10619.raw", "rb");
		FILE* fid = fopen(fileName.c_str(), "rb");

		fread(input_buffer, sizeof(unsigned short), height * width, fid);
		fclose(fid);

		//FOR AE NEED
		// get raw data ae param from sensor or get from ae out : ae_shutter \ ae_sensor_gain \ae_out_ispgain (must keep frame sync)
		// shutter =   
		// sensorgain =  
		//ispgain =			//update with ae out while match sensor param

		//update some isp intput param every frame 
		raw2bgr_handle->sensorgain = sensorgain;
		raw2bgr_handle->ispgain = ispgain;
		raw2bgr_handle->adrcgain = adrcgain;
		raw2bgr_handle->shutter = shutter;

		// 拿统计传给ae awb
		gxr_sraw2bgr_run_all(raw2bgr_handle);
		memcpy(awbstats.data(), raw2bgr_handle->handle[2], awb_blknumx * awb_blknumy * 5 * sizeof(int));
		memcpy(aestats.data(), raw2bgr_handle->handle[3], ae_blknumx * ae_blknumy * 8 * sizeof(int));
		memcpy(histgram.data(), raw2bgr_handle->handle[4], 256 * sizeof(int));
		memcpy(atfstats.data(), raw2bgr_handle->handle[5], atf_roiheight * sizeof(int));

		//saveAsFile("D:\\work\\PCMR\\Release\\output_test\\0_unpack_stats_10bit.txt", atfstats.data(), atf_roiheight);


		// 运行ae需要的每帧有变化的数据输入
		gxr_ae.frameId = frame_num;
		gxr_ae.statsBankNum = ae_blknumy;
		gxr_ae.statsBolckNum = ae_blknumx;
		gxr_ae.ae_stats = aestats.data();			//get from isp aestats
		gxr_ae.yhis_stats = histgram.data();		// get from isp yhis
		gxr_ae.sensorgain = (int)sensorgain * 100;  //scale 
		gxr_ae.shutter = (int)shutter;
		gxr_ae.atf_mode = (int)ANTIFLICKER_OFF;  // DEFAULT OFF; OR GET FROM ATF  ANTIFLICKER_50HZ

		gxr_ae.debug_level = Log_OFF;   //default: Log_OFF = 0
		gxr_ae.save_to_file = false;

		ae_err = ae_run(&gxr_ae);
		if (ae_err != 0x00) {
			printf("AE run error: %#x\r\n", ae_err);
			return ae_err;
		}

		// get ae out and save //write ae out to sensor and ispgain update while ae sensor  param effect
		float ae_shutter = (float)gxr_ae.ae_shutter;
		float ae_sensor_gain = min(gxr_ae.ae_adgain / 100.0f, 16.0f);   //ae out has scale 100
		float ae_out_ispgain = (float)max(1.0, gxr_ae.ae_adgain / 16 / 100.0);  //sensor adgain max is 16
		float ae_lux_result = gxr_ae.ae_lux_result / 1000.0f;  // lv scale 1000

		//update lux_index to isp current frame
		raw2bgr_handle->luxindex = ae_lux_result;

		/* ATF 算法主体*/
		gxr_atf.sofIndex = frame_num;
		gxr_atf.atf_stats = atfstats.data();
		gxr_atf.tuning_enable = 1;
		//gxr_atf.gain = sensorgain * 100;
		//gxr_atf.exposure_time = shutter;
		//gxr_atf.average_value = gxr_ae.Ymean;
		gxr_atf.gain = 200;
		gxr_atf.exposure_time = 4166;
		gxr_atf.average_value = 3825;
		//printf("start atf_run \n");

		//gxr_atf.fs_result.freq1.freq = 101;
		//gxr_atf.fs_result.freq2.freq = 62;
		//gxr_atf.fs_result.freq3.freq = 195;
		////update amp
		//gxr_atf.fs_result.freq1.amp = 4930;
		//gxr_atf.fs_result.freq2.amp = 1265;
		//gxr_atf.fs_result.freq3.amp = 455;
		//gxr_atf.fs_result.update_enable = 1;

		atf_err = atf_run(&gxr_atf);
		//printf("finished atf_run\n");

		if (atf_err != 0x00) {
			printf("AFD run error: %#x\r\n", atf_err);
			printf("finished error\n");
			return atf_err;
		}

		printf("[%02d] [alAFDLib] output result => flag_enable : %d, flag_bending : %d, afd_mode : %d, afd_mode_stable : %d\n",
			frame_num, gxr_atf.atf_output.flag_enable, gxr_atf.atf_output.flag_bending, gxr_atf.atf_output.atf_mode, gxr_atf.atf_output.atf_mode_stable);
		
		if (gxr_atf.atf_output.atf_mode == 1)
		{
			cnt_50 += 1;
		}
		else if (gxr_atf.atf_output.atf_mode == 2)
		{
			cnt_60 += 1;
		}
		else
		{
			cnt_0 += 1;
		}

		//运行awaverage_value = b需要的isp输出的统计
		gxr_awb.awb_stats = awbstats.data();
		//for (int i = 0; i < 1000; i++) {
		//	printf("AWB stats %#d\r\n", awbstats[i]);
		//}

		//运行awb需要的ae输出
		gxr_awb.awb_set_para.type = ALAWB_SET_PARAM_UPDATE_AE_REPORT;
		gxr_awb.awb_set_para.para.ae_report_update.bv = gxr_ae.nextbv;
		gxr_awb.awb_set_para.para.ae_report_update.non_comp_bv = gxr_ae.bgbv;
		gxr_awb.awb_set_para.para.ae_report_update.iso = gxr_ae.iso;
		gxr_awb.awb_set_para.para.ae_report_update.midtones_gain = gxr_ae.midtones_gain;
		gxr_awb.awb_set_para.para.ae_report_update.shadows_gain = gxr_ae.shadows_gain;

		awb_err = awb_run(&gxr_awb);
		if (awb_err != _AL_AWBLIB_SUCCESS) {
			printf("RUN ERROR %x\r\n", (unsigned int)awb_err);
			return awb_err;
		}
		//printf("[alAWBLib] CT: %3d\r\n", (int)gxr_awb.awb_output.color_temp);
		//printf("[alAWBLib] WB Gain %3d %3d %3d\r\n", gxr_awb.awb_output.wbgain.r_gain, gxr_awb.awb_output.wbgain.g_gain, gxr_awb.awb_output.wbgain.b_gain); 
		//printf("[alAWBLib] CCM %3f %3f %3f\r\n", gxr_awb.awb_output.final_CCM[0], gxr_awb.awb_output.final_CCM[1], gxr_awb.awb_output.final_CCM[2]);
		//printf("[alAWBLib] final_lsc %3f %3f \r\n", gxr_awb.awb_output.final_lsc[13 * 17], gxr_awb.awb_output.final_lsc[3 * 13 * 17 - 1]);

		//二次运行isp所需要的AWB AE数据输入
		wbgain[0] = gxr_awb.awb_output.wbgain.r_gain / 100.0f;
		wbgain[1] = gxr_awb.awb_output.wbgain.g_gain / 100.0f;
		wbgain[2] = gxr_awb.awb_output.wbgain.g_gain / 100.0f;
		wbgain[3] = gxr_awb.awb_output.wbgain.b_gain / 100.0f;
		memcpy(raw2bgr_handle->wbgain, wbgain, sizeof(wbgain));
		memcpy(raw2bgr_handle->ccm, gxr_awb.awb_output.final_CCM, sizeof(gxr_awb.awb_output.final_CCM));
		raw2bgr_handle->lsctable[0] = gxr_awb.awb_output.final_lsc;
		raw2bgr_handle->lsctable[1] = gxr_awb.awb_output.final_lsc + lsc_height * lsc_width;
		raw2bgr_handle->lsctable[2] = gxr_awb.awb_output.final_lsc + lsc_height * lsc_width * 2;
		raw2bgr_handle->lsctable[3] = gxr_awb.awb_output.final_lsc + lsc_height * lsc_width * 3;

		gxr_sraw2bgr_run_all(raw2bgr_handle);

		char ppmtemp[300];
		string ppmName;
		ppmName = path + "\\ppm\\";
		sprintf(ppmtemp, "%s_%d.ppm", ppmName.c_str(), frame_num);
		ppmWrite(ppmtemp, output_buffer, height, width);

		//ppmWrite("0.ppm", output_buffer, height, width);
	//}
		frame_num++;
	} while (!_findnext(hFile, &fileInfo));    //_findnext()返回类型为intptr_t而非long型
	frame_num -= 5;
	printf("\n[ATF result]toltal frame is %d;detect failed : %.2f\n", frame_num, cnt_0 * 100.0 / frame_num);
	printf("\n[ATF result]detect success percent : 50hz :%.2f\%; 60hz : %.2f\%\n", cnt_50 * 100.0 / frame_num, cnt_60 * 100.0 / frame_num);

	atf_err = atf_deinit(&gxr_atf);
	if (atf_err != 0x00) {
		printf("atf deinit error\r\n");
		return atf_err;
	}

	ae_err = ae_deinit(&gxr_ae);
	if (ae_err != 0x00) {
		printf("AE deinit error: %#x\r\n", ae_err);
		return ae_err;
	}

	awb_err = awb_deinit(&gxr_awb);
	if (awb_err != _AL_AWBLIB_SUCCESS) {
		printf("DEINIT ERROR %x\r\n", (unsigned int)awb_err);
		return awb_err;
	}

	gxr_sraw2bgr_release(raw2bgr_handle);
	delete raw2bgr_handle;
	delete input_buffer;
	delete output_buffer;

	return 0;
}