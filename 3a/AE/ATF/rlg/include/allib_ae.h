/****************************************************************************
*                                                                           *
*       This software and proprietary is confidential and may be used       *
*        only as expressly authorized by a licensing agreement from         *
*                                                                           *
*                            Altek Semiconductor                            *
*                                                                           *
*                   (C) COPYRIGHT 2022 ALTEK SEMICONDUCTOR                  *
*                            ALL RIGHTS RESERVED                            *
*                                                                           *
*                 The entire notice above must be reproduced                *
*                  on all copies and should not be removed.                 *
*                                                                           *
*****************************************************************************/
/**
@file allib_ae.h
@brief Definition of AE lib. type declaration
@author Rachel Lin
@date 2022/04/27
*/

#ifndef _AL_AE_H_
#define _AL_AE_H_

#ifdef __cplusplus
extern "C"
{
#endif

/******************************************************************************
* Include files
*******************************************************************************/

/******************************************************************************
*  Macro definitions
******************************************************************************/
/**
@def AL_MAX_AE_STATS_NUM
@brief Constant to identify the total blocks of AE stats
*/
#define AL_MAX_AE_STATS_NUM                     (864)  /*!< 36 x 24 total blocks */

/**
@def HW3A_AE_STATS_BUFFER_SIZE
@brief Constant to identify the hw3a AE stats buffer size
*/
#define HW3A_AE_STATS_BUFFER_SIZE               (27*1024 + AE_HWSTATS_INFO_SIZE)

/**
@def AL_MAX_ROI_NUM
@brief The maximum support number of ROI
*/
#define AL_MAX_ROI_NUM                          (10)

/********************************************************************************
*                           Type Declaration                                    *
********************************************************************************/
/* hw3a_stats */
#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
/**
@struct alhw3a_statisticsdldregion_t
@brief Identify the woi information
*/
struct alhw3a_statisticsdldregion_t {
    unsigned short uwborder_ratiox;
    unsigned short uwborder_ratioy;
    unsigned short uwblk_numx;
    unsigned short uwblk_numy;
    unsigned short uwoffset_ratiox;
    unsigned short uwoffset_ratioy;
};
#pragma pack(pop)  /* restore old alignment setting from stack */

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
/**
@struct alhw3a_ae_cfginfo_t
@brief HW3A configuration for AE
*/
struct alhw3a_ae_cfginfo_t {
    unsigned short token_id;
    struct alhw3a_statisticsdldregion_t ae_region;
};
#pragma pack(pop)  /* restore old alignment setting from stack */

/**
@enum alhw3a_ae_engine_id
@brief Specify the hw3a engine ID, e.g. 3A_a or 3A_b
@arg ALHW3A_A Indicate 3A_a for hw3a engine
@arg ALHW3A_B Indicate 3A_b for hw3a engine
@arg ALHW3A_MAX_INDEX The maximum number of engine ID
*/
enum alhw3a_ae_engine_id {
    ALHW2A_A,
    ALHW3A_B,
    ALHW3A_MAX_ENGINE_ID
};

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
/**
@struct alhw3a_ae_proc_data_t
@brief Recruit AE data for process
*/
struct alhw3a_ae_proc_data_t {
    unsigned long  udsys_sof_idx;  /*!< System SOF index, counting by framework */
    enum    alhw3a_ae_engine_id hw_engine_id;  /*!< hw engine ID, to specify where ae stats comes from */
};
#pragma pack(pop)  /* restore old alignment setting from stack */

/**
@enum ae_metering_mode_type_t
@brief The mode of metering table
@arg AE_METERING_AVERAGE Corresponds to average metering table
@arg AE_METERING_USERDEF_WT Corresponds to user-defined metering table
@arg AE_METERING_MAX_MODE The maximum number of metering mode
*/
enum ae_metering_mode_type_t {
    AE_METERING_AVERAGE,    /*!< If AE_METERING_AVERAGE is set, alAELib will be applied with average metering table.*/
    AE_METERING_USERDEF_WT, /*!< If AE_METERING_USERDEF_WT is set, alAELib will be applied with user-defined metering table which is generated by tuning tool.*/
    AE_METERING_MAX_MODE
};

/**
@enum ae_iso_mode_t
@brief The choices of ISO value
@arg AE_ISO_AUTO ISO value will be calculated automatically
@arg AE_ISO_MAX The maximum number of ISO value
*/
enum ae_iso_mode_t {
    AE_ISO_AUTO = 0,
    AE_ISO_100,
    AE_ISO_200,
    AE_ISO_400,
    AE_ISO_800,
    AE_ISO_1600,
    AE_ISO_3200,
    AE_ISO_6400,
    AE_ISO_12800,
    AE_ISO_MAX
};

/**
@typedef ae_converge_level_type_t
@brief AE converge speed level
*/
enum ae_converge_level_type_t {
    AE_CONVERGE_NORMAL, /* normal speed */
    AE_CONVERGE_DIRECT, /* fastest speed */
    AE_CONVERGE_FAST,   /* fast speed */
    AE_CONVERGE_SMOOTH, /* slower than normal, recommand for video or roi_ae  */
    AE_CONVERGE_SLOW,   /* slower than smooth, recommand for video or roi_ae  */
    AE_CONVERGE_SPEED_LVMAX
};

/**
@enum ae_antiflicker_mode_t
@brief The mode of anti-flicker
@arg ANTIFLICKER_OFF No need to fit in with anti-flicker
@arg ANTIFLICKER_50HZ Current anti-flicker mode is 50Hz
@arg ANTIFLICKER_60HZ Current anti-flicker mode is 60Hz
@arg ANTIFLICKER_MAX The maximum number of anti-flicker mode
*/
enum ae_antiflicker_mode_t {
    ANTIFLICKER_OFF = 0,
    ANTIFLICKER_50HZ,
    ANTIFLICKER_60HZ,
    ANTIFLICKER_MAX,
};


/**
@enum ae_debug_log
@brief Definition of debug log
*/
enum ae_debug_log {
    USERSET_AE_DEBUG_LOG_DISABLE = 0,   /*!< Disable debug log */
    USERSET_AE_DEBUG_LOG_NORMAL,        /*!< Enable debug log for normal flow */
    USERSET_AE_DEBUG_LOG_AE_STATS,      /*!< Enable debug log for AE bayer stats */
    USERSET_AE_DEBUG_LOG_BLOCK_Y_MEAN_8BIT,  /*!< Enable debug log for Block Y mean, e.g. 16*16 Block Y mean */
    USERSET_AE_DEBUG_LOG_MAX_INDEX,
};

/**
@typedef ae_frame_type_t
@brief AE frame type with IR status
*/
enum ae_frame_type_t {
    AE_FRAME_IR_OFF = 0,
    AE_FRAME_IR_ON,
    AE_FRAME_DUMMY
};

/**
@typedef ae_estframe_type_t
@brief AE process on each frame or frame pair
@arg AE_EST_EACH_FRAME: process all frame
@arg AE_EST_FRAME_PAIR: support IR on & IR off pair
*/
enum ae_estframe_type_t {
    AE_EST_EACH_FRAME = 0,
    AE_EST_FRAME_PAIR
};

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
/**
@struct ae_calibration_data_t
@brief Calibration data
*/
struct ae_calibration_data_t {
    unsigned long min_iso;         /*!< minimum ISO */
    unsigned long calib_r_gain;    /*!< scale 1000 */
    unsigned long calib_g_gain;    /*!< scale 1000 */
    unsigned long calib_b_gain;    /*!< scale 1000 */
};
#pragma pack(pop)  /* restore old alignment setting from stack */

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
/**
@struct ae_init_exposure_param_t
@brief Exposure parameter of initial value (first time to open camera)
*/
struct ae_init_exposure_param_t {
    unsigned long  exp_time;   /*!< unit:us, for initial, exposure time is only for reference, exposure line would be more precise */
    long   bv_val;     /*!< scale 1000, bv_val = 1000 means BV = 1 */
    unsigned short  ad_gain;    /*!< scale 100, if 1.0x, set 100 */
    unsigned short  iso;
	unsigned short midtones_gain; /*!< scale 100, if 1.0x, set 100 */
};
#pragma pack(pop)  /* restore old alignment setting from stack */

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
struct rect_roi_t {
    unsigned long w;
    unsigned long h;
    unsigned long left;
    unsigned long top;
};
#pragma pack(pop)  /* restore old alignment setting from stack */

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
/**
@struct ae_sensor_info_t
@brief Sensor information
*/
struct ae_sensor_info_t {
    unsigned long min_fps;  /*!< scale 100, if 16.0 FPS, input 1600 as min FPS, suggest value: 1600 */
    unsigned long max_fps;  /*!< scale 100, if 30.0 FPS, input 3000 as max FPS, suggest value: 3000 */

    unsigned long min_line_cnt;    /*!< sensor minimun exposure line, suggest value 1~ 4 (follow sensor FAE suggestion) */
    unsigned long max_line_cnt;    /*!< sensor maximun exposure line, suggest value 65535 (follow sensor FAE suggestion), which corresponding to min FPS setting
    if min FPS = 16, means max exposure time = 1/16 = 62.5 ms
    if 1 line = 20 us, max line count = 62.5ms / 20us = 3125 lines
    */
    unsigned long exposuretime_per_exp_line_ns;    /*!< used for more precise control.
    if set 0 , would use min FPS vs max line count to calculate automatically,
    note: use ns as units to keep precision, which would have difference for long exposure
    ex: min_fps = 15.99, max line = 3000
    1 line = 1s * 100/1599 / 3000 = 1000000000 (ns) *100 / 1599/3000
    = 20.846 (us)           = 20846 (ns)
    */

    unsigned long sw_min_exptime;   /*!< minimum exposure time for SW limitation, unit:us */
    unsigned long sw_max_exptime;   /*!< maximum exposure time for SW limitation, unit:us */

    unsigned long min_gain;  /*!< scale 100, if 1.0x, set 100, suggest value: 100 (1.0x is most setting for every sensor) */
    unsigned long max_gain;  /*!< scale 100, if 128.0x, set 12800 */

	unsigned short min_midtones_gain;

    unsigned long f_number_x1000;  /*!< Fn number, should refer to lens spec, if aperture = 2.0, here input 2000 */
};
#pragma pack(pop)  /* restore old alignment setting from stack */

#pragma pack(push) //push current alignment setting to stack
#pragma pack(4)    //new alignment setting
/**
@struct ae_ir_param_t
@brief IR information
*/
struct ae_ir_param_t {
    unsigned char  ir_level;            /*!< IR level, including clamp level, range:0-255 */
    unsigned char  ir_turnon_flag;      /*!< IR turn on flag, FALSE: Turn off, TRUE: Turn on */
};
#pragma pack(pop)  //restore old alignment setting from stack

#pragma pack(push) //push current alignment setting to stack
#pragma pack(4)    //new alignment setting
/**
@struct ae_ir_ctrl_cfg_t
@brief Dynamic IR configuration
*/
struct ae_ir_ctrl_cfg_t {
    unsigned char   ir_ctrl_enable;     /*!< FALSE: disable, TRUE: enable */
    unsigned char   max_ir_level;       /*!< Maximum IR level, including ir_clamp_level, range:ir_clamp_level < max_ir_level <=255 */
    unsigned char   ir_clamp_level;     /*!< IR clamp level, range:0-255 */
    unsigned char   allow_level_ctrl;   /*!< FALSE: no level control, only one ir level; TRUE: allow level control */
};
#pragma pack(pop)  //restore old alignment setting from stack

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
/**
@struct ae_sof_notify_param_t
@brief SOF information
*/
struct ae_sof_notify_param_t {
    enum ae_frame_type_t    nIRFrameType;   /*!< 0:frame of IR LED off, 1:frame of IR LED on, 2: frame of dummy */
    struct ae_ir_param_t    current_ir_para;/*!< Current IR ctrl parameters(Effective setting) */
    unsigned long sys_sof_index;   /*!< current system SOF index, counting by framework */
    unsigned long exp_time;        /*!< unit:us, 1.0s should set 1000000 */
    unsigned long exp_adgain;      /*!< scale 100, if 1.0x, set 100 */
	unsigned short  midtones_gain; /*!< current midtones_gain , scale 100, if 1.0, set 100 */
};
#pragma pack(pop)  /* restore old alignment setting from stack */

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
/**
@struct ae_awb_info_t
@brief AWB information for AE lib.
*/
struct ae_awb_info_t {
    unsigned short  gain_r;  /*!< 256 base */
    unsigned short  gain_g;  /*!< 256 base */
    unsigned short  gain_b;  /*!< 256 base */
};
#pragma pack(pop)  /* restore old alignment setting from stack */

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
struct rect_roi_wt_t {
    struct rect_roi_t roi;
    unsigned long weight;      /* Reserved para, NOT USED in this project ; unit: 1000, set 1000 to be default */
};
#pragma pack(pop)  /* restore old alignment setting from stack */

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
struct rect_roi_config_t {
    struct rect_roi_wt_t roi[AL_MAX_ROI_NUM];
    unsigned short  roi_count;          /* total valid ROI region numbers */
    unsigned short  ref_frame_width;    /* image width of object ROI */
    unsigned short  ref_frame_height;   /* image height of object ROI */
};
#pragma pack(pop)  /* restore old alignment setting from stack */

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
/**
@struct ae_set_parameter_init_t
@brief AE initial setting
*/
struct ae_set_parameter_init_t {
    /* tuning parameter setting */
    void   *ae_setting_data;    /*!< the pointer of ae setting file(tuning bin) */

    /* AE Debug info ptr */
    void   *ae_debug_info_ptr;  /*!< the pointer of ae debug info, please input a buffer that will store AE debug information */

    enum ae_antiflicker_mode_t      afd_flicker_mode;       /*!< anti-flicker mode */

    enum ae_metering_mode_type_t    ae_metering_mode;       /*!< AE metering mode */

    /*  basic control param */
    unsigned char ae_enable;            /*!< for initial, should be true */
    unsigned short ae_stats_size;       /*!< at least stats buffer size, unit: byte, ex. 16x12 = 16*12*32 + 40(info) = 6184 (byte) */

    /* sensor info setting, RAW size, fps , etc. */
    struct ae_sensor_info_t         preview_sensor_info;  /*!< Normal preview mode setting */

    /* initial AWB info */
    struct ae_awb_info_t            wb_data;    /*!< gain of rgb transfer to y (use when there's no otp), scale 256, set 256 means 1x gain */

    /* OTP data */
    struct ae_calibration_data_t    ae_calib_wb_gain;   /*!< Please get from Qmerge shading bin*/
    
    /* dynamic ir control cfg */
    struct ae_ir_ctrl_cfg_t         dynamic_ir_cfg;

    unsigned long external_lux_value;    /*!< The ambient lux value for exposure paramters of initial frame */
};
#pragma pack(pop)  /* restore old alignment setting from stack */

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
/**
@struct ae_set_param_content_t
@brief Parameter content of set-param
*/
struct ae_set_param_content_t {
	void   *ae_setting_data;									/*!< the pointer of ae setting file (tuning bin) */
    /* sensor info setting, fps , etc. */
    struct ae_sensor_info_t         preview_sensor_info;        /*!< Normal preview mode setting */
    /* frame based update command */
    struct ae_sof_notify_param_t    sof_notify_param;           /*!< Current sof notify param, should be updated for each SOF received */
    struct ae_set_parameter_init_t  ae_initial_setting;         /*!< Initial setting, basic setting related */
    struct rect_roi_config_t        ae_set_object_roi_setting;  /*!< should base on HW3A cropped domain */
    enum ae_metering_mode_type_t    ae_metering_mode;           /*!< AE metering mode */
    enum ae_converge_level_type_t   converge_speedlv;           /*!< AE converge speed */
    enum ae_iso_mode_t              manual_isolevel;            /*!< Manual ISO level */
    enum ae_estframe_type_t         ae_estframe_type;           /*!< AE process on each frame or frame pair (IR on & IR off pair) */
    enum ae_antiflicker_mode_t      afd_flicker_mode;           /*!< anti-flicker mode from AFD output results or UI setting */
    unsigned long                          manual_exptime;             /*!< Manual exposure time, unit:us, set 1000000 means 1.0s */
    unsigned long                          manual_adgain;              /*!< Manual adgain, scale 100, set 150 means 1.5x gain */
    short                           manual_ev_comp;             /*!< Manual EV compensation, range -2EV ~ +2EV, scale1000, e.g. Set 1500 means +1.5EV, Set -2000 means -2EV */

    unsigned char                           ae_enable;                  /*!< The switch of AE lib. If set false, skip ae estimation and the output will NOT be updated */
    unsigned short                          manual_ae_target;           /*!< Manual AE target, 8bit, scale100, e.g. Input 3825 means 38.25 */
    unsigned char                           wdr_enable;                 /*!< The switch of WDR lib. If set false, skip wdr estimation and the output will NOT be updated */
    unsigned char                           backlight_enable;           /*!< The switch of backlight compensation, 0: disable, 1: enable */
    unsigned char                           dark_mode_enable;           /*!< The switch of dark mode, 0: disable, 1: enable */
    unsigned char                           privacy_enable;             /*!< The switch of privacy mode control, 0: disable, 1: enable */
};
#pragma pack(pop)  /* restore old alignment setting from stack */

/**
@enum ae_set_param_type_t
@brief Set param command ID
*/
enum ae_set_param_type_t {
    AE_SET_PARAM_INVALID_ENTRY, /* invalid entry start */
    AE_SET_PARAM_INIT_SETTING,
    AE_SET_PARAM_ENABLE,        /* enable or disable ae estimation */
    AE_SET_PARAM_SOF_NOTIFY,    /* inform AE lib current SOF changed */
    AE_SET_PARAM_METERING_MODE,
    AE_SET_PARAM_CONVERGE_SPD,  /* control AE converge speed */
    AE_SET_PARAM_OBJECT_ROI,
    AE_SET_PARAM_PROCESS_FRAME_TYPE,    /* control AE process only on IR-on or all frame */
    AE_SET_PARAM_ANTIFLICKER_MODE,

    /* Manual control command */
    AE_SET_PARAM_MANUAL_ISO_LEVEL,
    AE_SET_PARAM_MANUAL_EXPTIME,
    AE_SET_PARAM_MANUAL_ADGAIN,
    AE_SET_PARAM_MANUAL_EV_COMPENSATION,

    AE_SET_PARAM_MANUAL_AE_TARGET,
    AE_SET_PARAM_WDR_ENABLE,
	AE_SET_PARAM_UPDATE_SETTING_FILE,
    AE_SET_PARAM_BACKLIGHT_ENABLE,
    AE_SET_PARAM_FACTORY_DARK_MODE,
    AE_SET_PARAM_ENABLE_UVC_PRIVACY,
    AE_SET_PARAM_MAX
};

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
/**
@struct ae_set_param_t
@brief Parameter body of set-param
*/
struct ae_set_param_t {
    enum  ae_set_param_type_t  ae_set_param_type;   /*!< Set-param-type specifies that which parameters users want to set */
    struct ae_set_param_content_t    set_param;     /*!< The content of parameters */
};
#pragma pack(pop)  /* restore old alignment setting from stack */

/**
@enum ae_get_param_type_t
@brief Get-param command ID
*/
enum ae_get_param_type_t {
    AE_GET_PARAM_INVALID_ENTRY,
    AE_GET_INIT_EXPOSURE_PARAM,
    AE_GET_ALHW3A_CONFIG,
    AE_GET_CURRENT_CALIB_DATA,
    AE_GET_CURRENT_WB,
    AE_GET_DEBUG_INFO,
    AE_GET_PARAM_OBJECT_ROI,
    AE_GET_PARAM_ANTIFLICKER_MODE,
    AE_GET_PARAM_MANUAL_EXPTIME,
    AE_GET_PARAM_MANUAL_ADGAIN,
    AE_GET_PARAM_EXPOSURE_LIMIT_RANGE,
    AE_GET_MANUAL_EXPTIME_GAIN_RESOLUTION,
    AE_GET_MANUAL_EV_COMPENSATION,
    AE_GET_PARAM_MAX
};

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
/**
@struct ae_deubg_info_t
@brief The size of debug information
 */
struct ae_deubg_info_t {
    unsigned long  size;
    void *ptr;  /* Require user to assign the buffer address through "ae_debug_info_ptr" if needed */
};
#pragma pack(pop)  /* restore old alignment setting from stack */

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
struct al_ae_exp_limit {
    unsigned long max_exptime;     /*!< unit:us, 1000000 means 1.0s */
    unsigned long min_exptime;     /*!< unit:us, 1000 means 1.0ms */
    unsigned short max_adgain;      /*!< sensor adgain limit, scale 100, 150 means 1.5x */
    unsigned short min_adgain;      /*!< sensor adgain limit, scale 100, 150 means 1.5x */
};
#pragma pack(pop)  /* restore old alignment setting from stack */

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
struct al_ae_exp_resolution {
    unsigned short exptime_gapvalue;      /*!< manual exposure time resolution for UVC command, unit:us */
    unsigned short adgain_gapvalue;       /*!< manual adgain resolution for UVC command, scale 100 */
};
#pragma pack(pop)  /* restore old alignment setting from stack */

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
/**
@struct ae_get_param_t
@brief Parameter body of get-param
*/
struct ae_get_param_t {
    enum ae_get_param_type_t                ae_get_param_type;      /*!< Get-param-type specifies that which parameters users want to get */
    union {
    struct ae_init_exposure_param_t ae_get_init_expo_param;     /*!< initial exposure setup */
    struct alhw3a_ae_cfginfo_t      alhw3a_aeconfig;            /*!< default hw3a config for reference */
    struct ae_calibration_data_t    calib_data;                 /*!< calibration data from initial setting, scale 1000 */
    struct ae_awb_info_t            wb_data;                    /*!< wb data from initial setting, scale 256 */
    struct ae_deubg_info_t          debug_info;                 /*!< debug info (buffer size) */
    struct rect_roi_config_t        object_roi_setting;         /*!< should base on HW3A cropped domain */
    struct al_ae_exp_limit          ae_exp_limit_range;         /*!< intersection of HW and SW exptime/adgain limitations */
    struct al_ae_exp_resolution     ae_manual_resolution;       /*!< manual reolution for UVC command */
    enum ae_antiflicker_mode_t      afd_flicker_mode;           /*!< anti-flicker mode from AFD output results or UI setting */
    unsigned long                          manual_exptime;             /*!< Get current manual exposure time, unit:us, 1000000 means 1.0s */
    unsigned short                          manual_adgain;              /*!< Get current manual adgain, scale 100, 150 means 1.5x gain */
	short                           manual_ev_comp;             /*!< Get current manual EV compensation, range -2EV ~ +2EV, scale1000, -1500 means -1.5EV*/
    } para;
};
#pragma pack(pop)  /* restore old alignment setting from stack */

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
/**
@struct ae_output_data_t
@brief Parameter body of AE output result
*/
struct ae_output_data_t {
    unsigned long  iso;                        /*!< ISO for AE estimation result */
    unsigned long  udexposure_time;            /*!< Exposure time for AE estimation result */
    unsigned long  udsensor_ad_gain;           /*!< Sensor ADGain for AE estimation result, scale100, e.g. 100 means 1.0x adgain */
    long   bvresult;                   /*!< BV value for current brightness (not update when AE disabled)*/
    long   bg_bvresult;                /*!< BV value from average mean (not update when AE disabled), for awb ae_non_comp_bv_val */
    unsigned long  lux_result;                 /*!< Lux value from average mean (not update when AE disabled)*/
    long   uwBLcomp;                   /*!< high dynamic scene BV compensation*/
    short   ae_converged;               /*!< 0:Not converged, 1:Converged */
    unsigned short  ymean100_8bit;              /*!< Average Y (8-bit), scale 100 */
    unsigned short  midtones_gain;              /*!< Gain for middle tone control */
    unsigned short  shadows_gain;               /*!< Gain for shadows tone control */
    unsigned short  ae_debug_info_valid_size;   /*!< The data size of debug info */
    unsigned char   next_ir_level;              /*!< Next IR level, including clamp level, range:0-255 */
    unsigned char   next_ir_turnon_flag;        /*!< Next IR turn on flag, FALSE: Turn off, TRUE: Turn on */
    unsigned char   is_privacy_mode;            /*!< shutter close or not, FALSE: shutter open, TRUE: shutter close */
    unsigned char   isface;                     /*!< face detect result, 1 : has a face, 0: no face */
    void    *pae_debug_info_ptr;        /*!< The data pointer of debug info */
};
#pragma pack(pop)  /* restore old alignment setting from stack */


/********************************************************************************/
/*                           Public Function Prototype                          */
/********************************************************************************/
/**
@fn unsigned int (* allib_ae_initial)
@brief AE lib. initial API, to load default setting
@param ae_init_buffer [Out], Buffer address of run-time buffer
@return Error code
*/
typedef unsigned int (*allib_ae_initial)(void **ae_init_buffer);

/**
@fn unsigned int (* allib_ae_deinit )
@brief AE lib. De-initial API, to release buffer
@param ae_obj [In], Address of run-time buffer
@return Error code
*/
typedef unsigned int (*allib_ae_deinit)(void *ae_obj);

/**
@fn unsigned int (* allib_ae_set_param )
@brief AE set parameter event for AE lib
@param param [In], structure of ae_set_param_t
@param ae_output [Out], Not support currently, please set to NULL
@param ae_runtime_dat [In], Address of run-time buffer
@return Error code
*/
typedef unsigned int (*allib_ae_set_param)(struct ae_set_param_t *param, struct ae_output_data_t *ae_output, void *ae_runtime_dat);

/**
@fn unsigned int (* allib_ae_get_param )
@brief AE get parameter event for AE lib
@param param [Out], structure of ae_set_param_t
@param ae_runtime_dat [In], Address of run-time buffer
@return Error code
*/
typedef unsigned int (*allib_ae_get_param)(struct ae_get_param_t *param, void *ae_runtime_dat);

/**
@fn unsigned int (* allib_ae_process )
@brief Do AE process
@param hw3a_ae_stats_data  [In], Address of hw3a AE stats
@param hw3a_yhis_stats_data[In], Address of hw3a YHis stats
@param ae_proc_data     [In], Recruit AE data for process
@param ae_runtime_dat   [In], Address of run-time buffer
@param ae_output        [Out], Address of AE lib. output data
@return Error code
*/
typedef unsigned int (*allib_ae_process)(void *hw3a_ae_stats_data, void *hw3a_yhis_stats_data, struct alhw3a_ae_proc_data_t ae_proc_data, void *ae_runtime_dat, struct ae_output_data_t *ae_output);

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
/**
@struct alaeruntimeobj
@brief AE lib function object (APIs address)
*/
struct alaeruntimeobj {
unsigned long  identityid;  /*!< framework tag for current instance */
void                 *ae;       /*!< runtime working buffer */
allib_ae_initial     initial;   /*!< Initial API for AE lib. */
allib_ae_deinit      deinit;    /*!< De-initial API for AE lib. */
allib_ae_set_param   set_param; /*!< Set-param API for AE lib. */
allib_ae_get_param   get_param; /*!< Get-param API for AE lib. */
allib_ae_process     process;   /*!< Process API for AE lib. */
};
#pragma pack(pop)  /* restore old alignment setting from stack */

#pragma pack(push) /* push current alignment setting to stack */
#pragma pack(4)    /* new alignment setting */
/**
@struct alaelib_version
@brief AE lib version
@arg major_version Main version of AE lib.
@arg minor_version Minor version of AE lib.
*/
struct alaelib_version {
    unsigned short major_version;
    unsigned short minor_version;
};
#pragma pack(pop)  /* restore old alignment setting from stack */

/**
@brief Get AE lib API address
@param aec_run_obj [Out], object of AE lib APIs address
@param identityID [In], framework tag for current instance
@return FALSE: loading with no error , TRUE: false loading function APIs address
*/
unsigned char allib_ae_loadfunc(struct alaeruntimeobj *aec_run_obj, unsigned long identityID);

/**
@brief Get AE lib version number
@param AE_LibVersion [Out], AE lib version number
*/
void allib_ae_getlib_version(struct alaelib_version *AE_LibVersion);

/**
@brief Control debug log flag
@param ae_debug_log_flag [In], The flag of debug log, see enum ae_debug_log
@return Error code
*/
unsigned int allib_ae_set_debug_log_flag(enum ae_debug_log ae_debug_log_flag);

/**
@brief Get AE lib working buffer size
@param None
@return Working buffer size (unit:byte)
*/
unsigned short allib_ae_getlib_runtimebuf_size(void);

typedef struct al4ahd {

    struct alaelib_version              ae_ver;
    struct alaeruntimeobj               ae_func_obj;
    struct ae_set_param_t               ae_set_para;
    struct ae_get_param_t               ae_get_para;
    struct ae_output_data_t             ae_output;
    struct alhw3a_ae_proc_data_t        ae_proc_data;
    void* ae_obj;

}al4ahd;

#ifdef __cplusplus
}  /* extern "C" */
#endif

#endif /* _AL_AE_H_ */
