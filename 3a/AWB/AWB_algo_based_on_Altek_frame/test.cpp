#include <string>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <io.h>  
#include <iostream>  
#include "./include/gxr_sraw2bgr.h"
#include "AWB_handle.h"
#include "./include/aeHandle.h"
#include<time.h>   //用到clock()函数
#include <fstream>
#include <iostream>
#include <windows.h>

//#define _DEBUG
using namespace std;
//#define EXEGen;

#ifdef SENSOR_ov64b
static int height = 3000; // ����ͼ��
static int width = 2920; // ����ͼ��
#endif

#ifdef SENSOR_471
static int height = 1744; // ����ͼ��
static int width = 2328; // ����ͼ��
#endif

static int const lsc_height = 13;
static int const lsc_width = 17;
static float lsctable[lsc_height * lsc_width * 4];
static unsigned short gmtablex[257] = { 0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816,820,824,828,832,836,840,844,848,852,856,860,864,868,872,876,880,884,888,892,896,900,904,908,912,916,920,924,928,932,936,940,944,948,952,956,960,964,968,972,976,980,984,988,992,996,1000,1004,1008,1012,1016,1020,1023 };
static unsigned short gmtabley[257] = { 0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816,820,824,828,832,836,840,844,848,852,856,860,864,868,872,876,880,884,888,892,896,900,904,908,912,916,920,924,928,932,936,940,944,948,952,956,960,964,968,972,976,980,984,988,992,996,1000,1004,1008,1012,1016,1020,1023 };
//static unsigned short gmtabley[257] = { 0, 22, 43, 60, 74, 86, 96, 106, 114, 123, 130, 137, 144, 153, 167, 180, 192, 204, 214, 227, 240, 252, 264, 275, 286, 297, 307, 317, 327, 336, 345, 354, 363, 371, 380, 388, 396, 403, 411, 418, 426, 433, 440, 447, 454, 461, 467, 474, 480, 487, 493, 499, 505, 511, 517, 523, 529, 534, 540, 546, 551, 557, 562, 567, 573, 578, 583, 588, 593, 598, 603, 608, 613, 618, 623, 627, 632, 637, 642, 646, 651, 655, 660, 664, 669, 673, 677, 682, 686, 690, 695, 699, 703, 707, 711, 715, 719, 723, 727, 731, 735, 739, 743, 747, 751, 755, 759, 762, 766, 770, 774, 777, 781, 785, 788, 792, 796, 799, 803, 806, 809, 811, 814, 816, 819, 822, 824, 827, 829, 832, 834, 837, 839, 841, 844, 846, 849, 851, 854, 856, 858, 861, 863, 865, 868, 870, 872, 875, 877, 879, 881, 884, 886, 888, 890, 893, 895, 897, 899, 901, 904, 906, 908, 910, 912, 914, 917, 919, 921, 923, 925, 927, 929, 931, 933, 935, 938, 940, 942, 944, 946, 948, 950, 952, 954, 956, 958, 960, 962, 964, 966, 968, 970, 972, 973, 975, 977, 979, 981, 983, 985, 987, 989, 991, 993, 994, 994, 995, 996, 996, 997, 997, 998, 999, 999, 1000, 1000, 1001, 1001, 1002, 1003, 1003, 1004, 1004, 1005, 1006, 1006, 1007, 1007, 1008, 1008, 1009, 1010, 1010, 1011, 1011, 1012, 1012, 1013, 1014, 1014, 1015, 1015, 1016, 1016, 1017, 1018, 1018, 1019, 1019, 1020, 1020, 1021, 1021, 1022, 1023, 1023 };
static unsigned short* input_buffer; // ����ͼ bayer unpack
static unsigned char* output_buffer; // ���ͼ bgr pack

static bool ppmWrite(char const* name, unsigned char* src, int rows, int cols)
{
	unsigned char* rgb = (unsigned char*)malloc(rows * cols * 3);
	size_t total = rows * cols * 3;
	for (size_t i = 0; i < total; i += 3)
	{
		rgb[i] = src[i + 2];
		rgb[i + 1] = src[i + 1];
		rgb[i + 2] = src[i];
	}

	char header[256];
	int szhead = snprintf(header, sizeof(header),
		"P%c\n# Generated by GXR Chen Jiayun\n%d %d\n255\n",
		static_cast<char>('5' + 1), cols, rows);
	FILE* fid = fopen(name, "wb");
	fwrite(header, 1, szhead, fid);
	fwrite(rgb, 1, rows * cols * 3, fid);
	fclose(fid);

	free(rgb);
	return true;
}


void getFiles(string path, vector<string>& files) {
	//文件句柄  
	intptr_t hFile = 0;
	//文件信息，声明一个存储文件信息的结构体  
	struct _finddata_t fileinfo;
	string p;  //字符串，存放路径
	if ((hFile = _findfirst(p.assign(path).append("\\*").c_str(), &fileinfo)) != -1)//若查找成功，则进入
	{
		do
		{
			//如果是目录,迭代之（即文件夹内还有文件夹）  
			if ((fileinfo.attrib & _A_SUBDIR))
			{
				//文件名不等于"."&&文件名不等于".."
				//判断时，两者都要忽略，不然就无限递归跳不出去了！
				if (strcmp(fileinfo.name, ".") != 0 && strcmp(fileinfo.name, "..") != 0)
					getFiles(p.assign(path).append("\\").append(fileinfo.name), files);
			}
			else
			{
				files.push_back(fileinfo.name);
				//files.push_back(p.assign(path).append("\\").append(fileinfo.name));
			}
		} while (_findnext(hFile, &fileinfo) == 0);
		//_findclose函数结束查找
		_findclose(hFile);
	}
}


int main(int argc, char** argv)
{
	int notMultiHandle = 1;				//是否按文件夹批量处理的标志位

	/* buffer */
	input_buffer = (unsigned short*)malloc(height * width * sizeof(unsigned short));
	output_buffer = (unsigned char*)malloc(height * width * 3 * sizeof(unsigned char));

	/* 算法句柄初始化 */
	printf("gxr_sraw2bgr version: %s\n", gxr_sraw2bgr_version().Version);
	gxr_sraw2bgr* raw2bgr_handle = new gxr_sraw2bgr;
	gxr_sraw2bgr_initialize(raw2bgr_handle);

	gxr_aehd gxr_ae;
	unsigned int ae_err = 0;
	/* AE算法初始化 */
	gxr_ae.ae_set_para.set_param.ae_initial_setting.ae_calib_wb_gain.min_iso = 100;   // scale 100
	gxr_ae.ae_set_para.set_param.ae_initial_setting.ae_calib_wb_gain.calib_b_gain = 1500;   // scale 1000
	gxr_ae.ae_set_para.set_param.ae_initial_setting.ae_calib_wb_gain.calib_g_gain = 1000;
	gxr_ae.ae_set_para.set_param.ae_initial_setting.ae_calib_wb_gain.calib_r_gain = 1500;
	gxr_ae.ae_set_para.set_param.ae_initial_setting.afd_flicker_mode = (enum ae_antiflicker_mode_t)0;
	// set AE enable
	gxr_ae.ae_set_para.set_param.ae_initial_setting.ae_enable = 1;
	//输入数据来自左目：0；来自右目：1
	gxr_ae.cameraId = 0;

	ae_err = ae_initial(&gxr_ae);
	if (ae_err != _AL_3ALIB_SUCCESS) {
		printf("AE init error: %#x\r\n", ae_err);
		return ae_err;
	}

	gxr_awbhd gxr_awb;
	gxr_awbhd gxr_awb2;
	//for (int i = 100; i < 120; i++) {
	//	printf("AWB stats %#d\r\n", awbstats[i]);
	//}

	unsigned int awb_err = _AL_AWBLIB_SUCCESS;
	unsigned int load_stats_err = 0;

	//执行awb 1的初始化
	gxr_awb.awb_set_para.para.awb_calib_data.calib_r_gain = 1000;
	gxr_awb.awb_set_para.para.awb_calib_data.calib_g_gain = 1000;
	gxr_awb.awb_set_para.para.awb_calib_data.calib_b_gain = 1000;

	gxr_awb.tuning_enable = 1;
	gxr_awb.awb_handle_param.params_from_txt.load_params_from_debug_txt = 1;
	gxr_awb.awb_handle_param.params_from_txt.load_params_from_buffer = 1;
	//gxr_awb.identityid = 0;	//删掉则不作用时序算法。因为仿真的时候有的图像不是连续的
	awb_err = awb_initial(&gxr_awb);
	if (awb_err != _AL_AWBLIB_SUCCESS) {
		printf("INIT ERROR %x\r\n", (unsigned int)awb_err);
		return awb_err;
	}

	////执行awb 2的初始化
	gxr_awb2.awb_set_para.para.awb_calib_data.calib_r_gain = 1000;
	gxr_awb2.awb_set_para.para.awb_calib_data.calib_g_gain = 1000;
	gxr_awb2.awb_set_para.para.awb_calib_data.calib_b_gain = 1000;

	gxr_awb2.tuning_enable = 1;
	//gxr_awb.identityid = 0;	//删掉则不作用时序算法。因为仿真的时候有的图像不是连续的
	awb_err = awb_initial(&gxr_awb2);
	if (awb_err != _AL_AWBLIB_SUCCESS) {
		printf("INIT ERROR %x\r\n", (unsigned int)awb_err);
		return awb_err;
	}

	char verbose = 7;
	int rpat = GXR_Raw_BGGR;	//JD1：GXR_Raw_GRBG;/BGGR/RGGB
	int depth = 10;
	int bpc = 0; // ��ʱû��
	char wben = 1, expen = 1; // ��ƽ����ع��ⲿ����
	int awbsat = 255; // 8λ������
	int awb_blknumx = 32;
	int awb_blknumy = 32;
	vector<int> awbstats(awb_blknumx * awb_blknumy * 5);
	int aesat = 1023; // 10λ������
	int ae_blknumx = 16;
	int ae_blknumy = 16;
	vector<int> aestats(ae_blknumx * ae_blknumy * 8);
	vector<int> histgram(256);
	int top = 0, bottom = height, left = 0, right = width; // ��������
	float wbgain[4] = { 1,1,1,1 }; // r gr gb b
	int blacklevel[4] = { 64, 64, 64, 64 }; // ��10bit
	float ccm[9] = { 1.0f,-0.0f,-0.0f,-0.0f,1.0f,-0.0f,0.0f,-0.0f,1.0f }; // rgb
	float sensorgain = 8;
	float ispgain = 1;
	float adrcgain = 1;
	float shutter = 4000; // us
	float luxindex = 1;

	raw2bgr_handle->verbose = verbose;
	raw2bgr_handle->rpat = rpat;
	raw2bgr_handle->depth = depth;
	raw2bgr_handle->bpc = bpc;
	raw2bgr_handle->height = height;
	raw2bgr_handle->width = width;
	raw2bgr_handle->top = top;
	raw2bgr_handle->bottom = bottom;
	raw2bgr_handle->left = left;
	raw2bgr_handle->right = right;
	raw2bgr_handle->wben = wben;
	raw2bgr_handle->expen = expen;
	raw2bgr_handle->awbsat = awbsat;
	raw2bgr_handle->awb_blknumx = awb_blknumx;
	raw2bgr_handle->awb_blknumy = awb_blknumy;
	raw2bgr_handle->aesat = aesat;
	raw2bgr_handle->ae_blknumx = ae_blknumx;
	raw2bgr_handle->ae_blknumy = ae_blknumy;
	memcpy(raw2bgr_handle->blacklevel, blacklevel, sizeof(blacklevel));
	raw2bgr_handle->sensorgain = sensorgain;
	raw2bgr_handle->ispgain = ispgain;
	raw2bgr_handle->adrcgain = adrcgain;
	raw2bgr_handle->shutter = shutter;
	raw2bgr_handle->luxindex = luxindex;
	raw2bgr_handle->lsc_height = lsc_height;
	raw2bgr_handle->lsc_width = lsc_width;
	raw2bgr_handle->lsctable[0] = lsctable;
	raw2bgr_handle->lsctable[1] = lsctable + lsc_height * lsc_width;
	raw2bgr_handle->lsctable[2] = lsctable + lsc_height * lsc_width * 2;
	raw2bgr_handle->lsctable[3] = lsctable + lsc_height * lsc_width * 3;
	raw2bgr_handle->gmtablex = gmtablex;
	raw2bgr_handle->gmtabley = gmtabley;
	raw2bgr_handle->input = input_buffer;
	raw2bgr_handle->output = output_buffer;
	//for save ae out, init keep with ini file
	float ae_sensor_gain = sensorgain;
	float ae_shutter = shutter;				 // us
	float ae_out_ispgain = ispgain;
	float ae_lux_result = luxindex;

	LARGE_INTEGER t1, t2, tc;
	QueryPerformanceFrequency(&tc);
	float time = 0.0;
	bool save_gain = 1;
	int frame_num = 0;
	std::ofstream outfile("D:\\work\\gitlab\\AWB\\AWB_algo_based_on_Altek_frame\\gt.txt");

	if(notMultiHandle){
		string FilePath = "D:\\data\\aa\\";		//目录一定要干净，只有.raw文件
		string StorePath = "D:\\data\\aa\\";
		string storeType     = ".ppm";
		vector<string> FileName_List;

		//string FilePath2 = "D:\\work\\IQ\\AlightAll";
		//string StorePath2 = "D:\\work\\shuangmu\\2out";
		//vector<string> FileName_List2;

		//获取该路径下的所有文件  
		getFiles(FilePath, FileName_List);
		//getFiles(FilePath2, FileName_List2);

		for (int file_num = 0; file_num < FileName_List.size(); file_num++) {
			string input_tmp = FilePath + "//" + FileName_List[file_num];
			string output_tmp = StorePath + "//" + FileName_List[file_num] + storeType;
			const char* input_name = input_tmp.c_str();
			const char* output_name = output_tmp.c_str();

			//string input_tmp2 = FilePath2 + "//" + FileName_List2[file_num];
			//string output_tmp2 = StorePath2 + "//" + FileName_List2[file_num] + storeType;
			//const char* input_name2 = input_tmp2.c_str();
			//const char* output_name2 = output_tmp2.c_str();

			/* lens shading */
			for (int i = 0; i < sizeof(lsctable) / sizeof(float); i++)
				lsctable[i] = 1.f;


			FILE* fid = fopen(input_name, "rb");
			fread(input_buffer, sizeof(unsigned short), height * width, fid);
			fclose(fid);

			//update some isp intput param every frame 
			raw2bgr_handle->sensorgain = sensorgain;
			raw2bgr_handle->ispgain = ispgain;
			raw2bgr_handle->adrcgain = adrcgain;
			raw2bgr_handle->shutter = shutter;

			gxr_sraw2bgr_run_all(raw2bgr_handle);
			memcpy(awbstats.data(), raw2bgr_handle->handle[2], awb_blknumx * awb_blknumy * 5 * sizeof(int));
			memcpy(aestats.data(), raw2bgr_handle->handle[3], ae_blknumx * ae_blknumy * 8 * sizeof(int));
			memcpy(histgram.data(), raw2bgr_handle->handle[4], 256 * sizeof(int));

			// 运行ae需要的每帧有变化的数据输入
			gxr_ae.ae_set_para.set_param.sof_notify_param.sys_sof_index = frame_num;
			gxr_ae.ae_stats = aestats.data();			//get from isp aestats
			gxr_ae.yhis_stats = histgram.data();		// get from isp yhis
			gxr_ae.ae_set_para.set_param.sof_notify_param.exp_adgain = (int)sensorgain * 100;  //scale 
			gxr_ae.ae_set_para.set_param.sof_notify_param.exp_time = (int)shutter;
			gxr_ae.ae_set_para.set_param.sof_notify_param.midtones_gain = gxr_ae.ae_get_para.para.ae_get_init_expo_param.midtones_gain;
			gxr_ae.ae_set_para.set_param.afd_flicker_mode = ANTIFLICKER_OFF;  // DEFAULT OFF; OR GET FROM ATF

			//ae_err = ae_run(&gxr_ae);
			//if (ae_err != _AL_3ALIB_SUCCESS) {
			//	printf("AE run error: %#x\r\n", ae_err);
			//	return ae_err;
			//}
			// get ae out and save //write ae out to sensor and ispgain update while ae sensor  param effect
			ae_shutter = (float)gxr_ae.ae_output.udexposure_time;
			ae_sensor_gain = gxr_ae.ae_output.udsensor_ad_gain / 100.0f;   //ae out has scale 100
			ae_out_ispgain = (float)max(1.0, gxr_ae.ae_output.udsensor_ad_gain / 16 / 100.0);  //sensor adgain max is 16
			ae_lux_result = gxr_ae.ae_output.lux_result / 1000.0f;  // lv scale 1000
			//update lux_index to isp current frame
			raw2bgr_handle->luxindex = ae_lux_result;

			//执行awb 1的一帧算法
			gxr_awb.awb_stats = awbstats.data();
			struct ae_output_data_t* ae_output = &(gxr_ae.ae_output);
			gxr_awb.awb_set_para.type = ALAWB_SET_PARAM_UPDATE_AE_REPORT;
			//gxr_awb.awb_set_para.para.ae_report_update.ae_converge       = ae_output->ae_converged;
			gxr_awb.awb_set_para.para.ae_report_update.bv = ae_output->bvresult;
			gxr_awb.awb_set_para.para.ae_report_update.non_comp_bv = ae_output->bg_bvresult;
			//#ifdef  _DEBUG
			//		gxr_awb.awb_set_para.para.ae_report_update.non_comp_bv = 1800;
			//#endif
			gxr_awb.awb_set_para.para.ae_report_update.iso = ae_output->iso;
			gxr_awb.awb_set_para.para.ae_report_update.midtones_gain = ae_output->midtones_gain;
			gxr_awb.awb_set_para.para.ae_report_update.shadows_gain = ae_output->shadows_gain;

			gxr_awb.debug_level = AWBDebug;   //default: Log_OFF = 0
			//gxr_ae.debug_level = Log_OFF;   //default: Log_OFF = 0
			gxr_awb.save_to_file = 1;
			gxr_awb.identityid = 0;

			QueryPerformanceCounter(&t1);
			awb_err = awb_run(&gxr_awb);
			QueryPerformanceCounter(&t2);

			if (awb_err != _AL_AWBLIB_SUCCESS) {
				printf("RUN ERROR %x\r\n", (unsigned int)awb_err);
				return awb_err;
			}
			printf("-----------Camera 1-----------\r\n");
			cout << "--------------------name---------------------:" << FileName_List[file_num].c_str() << endl;
			printf("[alAWBLib] CT: %3d\r\n", (int)gxr_awb.awb_output.color_temp);
			printf("[alAWBLib] no shift rg,bg: %3d %3d \r\n", gxr_awb.awb_output.rg_allbalance, gxr_awb.awb_output.bg_allbalance);
			printf("[alAWBLib] (rg,bg): %3f %3f \r\n", 100 / (float)gxr_awb.awb_output.wbgain.r_gain, 100 / (float)gxr_awb.awb_output.wbgain.b_gain);
			printf("[alAWBLib] CCM %3f %3f %3f\r\n", gxr_awb.awb_output.final_CCM[0], gxr_awb.awb_output.final_CCM[1], gxr_awb.awb_output.final_CCM[2]);
			//printf("[alAWBLib] CCM %3f %3f %3f\r\n", gxr_awb.awb_output.final_CCM[3], gxr_awb.awb_output.final_CCM[4], gxr_awb.awb_output.final_CCM[5]);
			//printf("[alAWBLib] CCM %3f %3f %3f\r\n", gxr_awb.awb_output.final_CCM[6], gxr_awb.awb_output.final_CCM[7], gxr_awb.awb_output.final_CCM[8]);
			printf("[alAWBLib] final_lsc %3f %3f \r\n", gxr_awb.awb_output.final_lsc[13 * 17], gxr_awb.awb_output.final_lsc[3 * 13 * 17 - 1]);
			//for (int i = 0; i < 13; i++) {
			//	for (int j = 0; j < 17; j++) {
			//	printf("%3f,", gxr_awb.awb_output.final_lsc[i * 13 + j]);
			//	}
			//}
			float cast = ((t2.QuadPart - t1.QuadPart) / (tc.QuadPart / 1000.0));
			time += cast;

			wbgain[0] = gxr_awb.awb_output.wbgain.r_gain / 100.0f;
			wbgain[1] = gxr_awb.awb_output.wbgain.g_gain / 100.0f;
			wbgain[2] = gxr_awb.awb_output.wbgain.g_gain / 100.0f;
			wbgain[3] = gxr_awb.awb_output.wbgain.b_gain / 100.0f;

			//wbgain[0] = 1;
			//wbgain[1] = 1.0;
			//wbgain[2] = 1.0;
			//wbgain[3] = 1;

			memcpy(raw2bgr_handle->wbgain, wbgain, sizeof(wbgain));
			memcpy(raw2bgr_handle->ccm, gxr_awb.awb_output.final_CCM, sizeof(gxr_awb.awb_output.final_CCM));
			raw2bgr_handle->ispgain = ispgain;

			raw2bgr_handle->lsctable[0] = gxr_awb.awb_output.final_lsc;
			raw2bgr_handle->lsctable[1] = gxr_awb.awb_output.final_lsc + lsc_height * lsc_width;
			raw2bgr_handle->lsctable[2] = gxr_awb.awb_output.final_lsc + lsc_height * lsc_width * 2;
			raw2bgr_handle->lsctable[3] = gxr_awb.awb_output.final_lsc + lsc_height * lsc_width * 3;

			gxr_sraw2bgr_run_all(raw2bgr_handle);
			ppmWrite(output_name, output_buffer, height, width);

//******************************************双目-右目******************************************************

			//FILE* fid2 = fopen(input_name2, "rb");
			//fread(input_buffer, sizeof(unsigned short), height * width, fid2);
			//fclose(fid2);

			////update some isp intput param every frame 
			//raw2bgr_handle->sensorgain = sensorgain;
			//raw2bgr_handle->ispgain = ispgain;
			//raw2bgr_handle->adrcgain = adrcgain;
			//raw2bgr_handle->shutter = shutter;

			//gxr_sraw2bgr_run_all(raw2bgr_handle);
			//memcpy(awbstats.data(), raw2bgr_handle->handle[2], awb_blknumx * awb_blknumy * 5 * sizeof(int));
			//memcpy(aestats.data(), raw2bgr_handle->handle[3], ae_blknumx * ae_blknumy * 8 * sizeof(int));
			//memcpy(histgram.data(), raw2bgr_handle->handle[4], 256 * sizeof(int));

			//// 运行ae需要的每帧有变化的数据输入
			//ae_lux_result = gxr_ae.ae_output.lux_result / 1000.0f;  // lv scale 1000
			////update lux_index to isp current frame
			//raw2bgr_handle->luxindex = ae_lux_result;

			////执行awb的一帧算法
			//gxr_awb2.awb_stats = awbstats.data();
			//gxr_awb2.awb_set_para.type = ALAWB_SET_PARAM_UPDATE_AE_REPORT;
			////gxr_awb.awb_set_para.para.ae_report_update.ae_converge       = ae_output->ae_converged;
			//gxr_awb2.awb_set_para.para.ae_report_update.bv = ae_output->bvresult;
			//gxr_awb2.awb_set_para.para.ae_report_update.non_comp_bv = ae_output->bg_bvresult;

			//gxr_awb2.awb_set_para.para.ae_report_update.iso = ae_output->iso;
			//gxr_awb2.awb_set_para.para.ae_report_update.midtones_gain = ae_output->midtones_gain;
			//gxr_awb2.awb_set_para.para.ae_report_update.shadows_gain = ae_output->shadows_gain;

			//gxr_awb2.debug_level = AWBDebug;   //default: Log_OFF = 0
			//gxr_awb2.save_to_file = 1;
			//gxr_awb2.identityid = 1;
			//awb_err = awb_run(&gxr_awb2);
			//if (awb_err != _AL_AWBLIB_SUCCESS) {
			//	printf("RUN ERROR %x\r\n", (unsigned int)awb_err);
			//	return awb_err;
			//}
			//printf("-----------Camera 2-----------\r\n");
			//cout << "--------------------name---------------------:" << FileName_List2[file_num].c_str() << endl;
			//printf("[alAWBLib] CT: %3d\r\n", (int)gxr_awb2.awb_output.color_temp);
			//printf("[alAWBLib] (rg,bg): %3f %3f \r\n", 100 / (float)gxr_awb2.awb_output.wbgain.r_gain, 100 / (float)gxr_awb2.awb_output.wbgain.b_gain);
			////printf("[alAWBLib] CCM %3f %3f %3f\r\n", gxr_awb.awb_output.final_CCM[0], gxr_awb.awb_output.final_CCM[1], gxr_awb.awb_output.final_CCM[2]);[alAWBLib] CT: 5875 [alAWBLib] WB Gain 202 100 170
			//printf("[alAWBLib] final_lsc %3f %3f \r\n", gxr_awb2.awb_output.final_lsc[13 * 17], gxr_awb2.awb_output.final_lsc[3 * 13 * 17 - 1]);

			//wbgain[0] = gxr_awb2.awb_output.wbgain.r_gain / 100.0f;
			//wbgain[1] = gxr_awb2.awb_output.wbgain.g_gain / 100.0f;
			//wbgain[2] = gxr_awb2.awb_output.wbgain.g_gain / 100.0f;
			//wbgain[3] = gxr_awb2.awb_output.wbgain.b_gain / 100.0f;

			//memcpy(raw2bgr_handle->wbgain, wbgain, sizeof(wbgain));
			//memcpy(raw2bgr_handle->ccm, gxr_awb2.awb_output.final_CCM, sizeof(gxr_awb2.awb_output.final_CCM));
			//raw2bgr_handle->ispgain = ispgain;
			//raw2bgr_handle->lsctable[0] = gxr_awb2.awb_output.final_lsc;
			//raw2bgr_handle->lsctable[1] = gxr_awb2.awb_output.final_lsc + lsc_height * lsc_width;
			//raw2bgr_handle->lsctable[2] = gxr_awb2.awb_output.final_lsc + lsc_height * lsc_width * 2;
			//raw2bgr_handle->lsctable[3] = gxr_awb2.awb_output.final_lsc + lsc_height * lsc_width * 3;

			//gxr_sraw2bgr_run_all(raw2bgr_handle);
			//ppmWrite(output_name2, output_buffer, height, width);
//******************************************双目-右目******************************************************

			if (save_gain = 1) {
				if (!outfile.is_open()) {
					std::cerr << "无法打开文件" << std::endl;
				}
				else {
					outfile << FileName_List[file_num].c_str() << " " << wbgain[0] << " " << wbgain[3] << std::endl;
				}
			}
			frame_num++;
		}
		printf("---------------\n");
		printf("total frame num: %d; total time cost: %f ms\n", frame_num, time);
		printf("avg time cost: %f ms, max time: %f ms, min time : %f ms\n", time / (frame_num));
		printf("---------------\n");

		gxr_sraw2bgr_release(raw2bgr_handle);
		delete raw2bgr_handle;
		free(input_buffer);
		free(output_buffer);
	}
}


