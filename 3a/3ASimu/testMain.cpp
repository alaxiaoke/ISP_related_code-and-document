#include <string>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <direct.h>

#include <Windows.h>
#include "gxr_sraw2bgr.h"
#include "AWB_handle.h"
#include "aeHandle.h"
#include "atfHandle.h"

#include <io.h>
#include <stdio.h>
#include <iostream>
#include <malloc.h>
#include <queue>
#include <fstream>
using namespace std;

//static int height = 3000; 
//static int width = 2920; 
static int height = 1744;
static int width = 2328;
static int const lsc_height = 13;
static int const lsc_width = 17;
static float lsctable[lsc_height * lsc_width * 4];
static unsigned short gmtablex[257] = { 0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,252,256,260,264,268,272,276,280,284,288,292,296,300,304,308,312,316,320,324,328,332,336,340,344,348,352,356,360,364,368,372,376,380,384,388,392,396,400,404,408,412,416,420,424,428,432,436,440,444,448,452,456,460,464,468,472,476,480,484,488,492,496,500,504,508,512,516,520,524,528,532,536,540,544,548,552,556,560,564,568,572,576,580,584,588,592,596,600,604,608,612,616,620,624,628,632,636,640,644,648,652,656,660,664,668,672,676,680,684,688,692,696,700,704,708,712,716,720,724,728,732,736,740,744,748,752,756,760,764,768,772,776,780,784,788,792,796,800,804,808,812,816,820,824,828,832,836,840,844,848,852,856,860,864,868,872,876,880,884,888,892,896,900,904,908,912,916,920,924,928,932,936,940,944,948,952,956,960,964,968,972,976,980,984,988,992,996,1000,1004,1008,1012,1016,1020,1023};
static unsigned short gmtabley[257] = { 0,51,87,113,135,153,170,185,199,211,223,235,245,256,265,275,284,293,301,309,317,325,332,339,346,353,360,367,373,379,386,392,398,404,409,415,421,426,431,437,442,447,452,457,462,467,472,477,481,486,490,495,499,504,508,513,517,521,525,530,534,538,542,546,550,554,558,561,565,569,573,576,580,584,587,591,595,598,602,605,609,612,616,619,622,626,629,632,636,639,642,645,649,652,655,658,661,664,667,670,674,677,680,683,686,689,691,694,697,700,703,706,709,712,714,717,720,723,726,728,731,734,737,739,742,745,747,750,753,755,758,760,763,766,768,771,773,776,778,781,783,786,788,791,793,796,798,801,803,805,808,810,813,815,817,820,822,824,827,829,831,834,836,838,841,843,845,847,850,852,854,856,859,861,863,865,867,870,872,874,876,878,880,883,885,887,889,891,893,895,897,899,901,904,906,908,910,912,914,916,918,920,922,924,926,928,930,932,934,936,938,940,942,944,946,948,950,952,954,955,957,959,961,963,965,967,969,971,973,974,976,978,980,982,984,986,987,989,991,993,995,997,998,1000,1002,1004,1006,1007,1009,1011,1013,1015,1016,1018,1020,1022,1023 };
static unsigned short* input_buffer; // ����ͼ bayer unpack
static unsigned char* output_buffer; // ���ͼ bgr pack

static int woiheight = 1744;
static int woiwidth = 2328;
static unsigned short* crop_input_buffer;

float lastexposure[2];
float actualexposure[2];
int allConverge[2] = { 0 };
int flag = 1;
float missGain = 1.0f;
queue<vector<float>>    expousureList;
queue<vector<float>>    expousureList2;
queue<vector<float>>    expousureraw;

struct fileList
{
	char filename[260];
	int fileidx;
};


//static bool ppmWrite(char const* name, unsigned char* src, int rows, int cols)
//{
//	char header[256];
//	int szhead = snprintf(header, sizeof(header),
//		"P%c\n# Generated by GXR Chen Jiayun\n%d %d\n255\n",
//		static_cast<char>('5' + 1), cols, rows);
//	FILE* fid = fopen(name, "wb");
//	fwrite(header, 1, szhead, fid);
//	fwrite(src, 1, rows * cols * 3, fid);
//	fclose(fid);
//	return true;
//}


static bool ppmWrite(char const* name, unsigned char* src, int rows, int cols)
{
	unsigned char* rgb = (unsigned char*)malloc(rows * cols * 3);
	size_t total = rows * cols * 3;
	for (size_t i = 0; i < total; i += 3)
	{
		rgb[i] = src[i + 2];
		rgb[i + 1] = src[i + 1];
		rgb[i + 2] = src[i];
	}
	char header[256];
	int szhead = snprintf(header, sizeof(header),
		"P%c\n# Generated by GXR Chen Jiayun\n%d %d\n255\n",
		static_cast<char>('5' + 1), cols, rows);
	FILE* fid = fopen(name, "wb");
	fwrite(header, 1, szhead, fid);
	fwrite(rgb, 1, rows * cols * 3, fid);
	fclose(fid);
	free(rgb);
	return true;
}

int rawModify(unsigned short* p, float gain)
{
	int length = woiheight * woiwidth;
	printf("gain %f  %u %u %u %u, %d %d\n", gain, *(p + 0), *(p + 10), *(p + 500), *(p + 1000), sizeof(*(p + 0)), sizeof(unsigned short));
	for (int i = 0; i < length; i++)
	{
		*(p + i) = (*(p + i) - 64 ) > 0 ? (int)((*(p + i) - 64)/959.0f * 1023* gain + 64.5) : 64;
		*(p + i) = (*(p + i) > 1023) ? 1023 : *(p + i);

	}
	printf("gain %f  %u %u %u %u, %d %d\n", gain, *(p + 0), *(p + 10), *(p + 500), *(p + 1000), sizeof(*(p + 0)), sizeof(unsigned short));
	return 0;
}

void saveRaw(const unsigned short* p, char* savePath) {
	if (p == NULL)
	{
		std::cout << "raw path is error" << endl;
		return;
	}
	FILE* fp;
	fp = fopen(savePath, "wb");
	if (fp == NULL)
	{
		std::cout << "file point create fail" << endl;
		return;
	}
	fwrite(p, sizeof(unsigned short),woiheight * woiwidth, fp);
	printf("\nsaveRaw1 %u %u %u %u, %d %d", *(p + 0), *(p + 10), *(p + 500), *(p + 1000), sizeof(*(p + 0)), sizeof(unsigned short));
	fclose(fp);
	return;
}



int sortByIdx(const void* pdata1, const void* pdata2)
{
	if (((fileList*)pdata1)->fileidx < ((fileList*)pdata2)->fileidx) return -1;
	if (((fileList*)pdata1)->fileidx > ((fileList*)pdata2)->fileidx) return 1;
	return 0;
}

int checkinwoi(int i)
{
	for (int x = 4; x <= 1732; x++)
	{
		if (i >= x * 1800 + 4 && i <= x * 1800 + 1795)
		{
			return true;
		}
	}
	return false;
}


int main(int argc, char** argv)
{
	/* buffer */
	input_buffer = (unsigned short*)malloc(height * width * sizeof(unsigned short));
	output_buffer = (unsigned char*)malloc(woiheight * woiwidth * 3 * sizeof(unsigned char));
	crop_input_buffer = (unsigned short*)malloc(woiheight * woiwidth * sizeof(unsigned short));
	/* lens shading init*/
	for (int i = 0; i < sizeof(lsctable) / sizeof(float); i++)
		lsctable[i] = 1.f;

	/* handle init */
	printf("gxr_sraw2bgr version: %s\n", gxr_sraw2bgr_version().Version);
	gxr_sraw2bgr* raw2bgr_handle = new gxr_sraw2bgr;
	gxr_sraw2bgr_initialize(raw2bgr_handle);

	gxr_awbhd gxr_awb;
	gxr_aehd gxr_ae;
	gxr_aehd gxr_ae_c2;
	gxr_atfhd gxr_atf;
	unsigned int ae_err = 0x00;
	unsigned int awb_err = _AL_AWBLIB_SUCCESS;
	unsigned int atf_err = 0x00;

	/* param init */
	char verbose = 7;
	int rpat = GXR_Raw_BGGR;
	int depth = 10;
	int bpc = 0;
	char wben = 1, expen = 1, atfen = 1; //ae awb enable
	int awbsat = 255;
	int awb_blknumx = 16;
	int awb_blknumy = 16;
	vector<int> awbstats(awb_blknumx * awb_blknumy * 5);
	int aesat = 1023;
	int ae_blknumx = 16;
	int ae_blknumy = 16;
	vector<int> aestats(ae_blknumx * ae_blknumy * 8);
	vector<int> histgram(256);
	int atf_roiheight = woiheight;
	int atf_roiwidth = woiwidth;
	vector<int> atfstats(atf_roiheight);
	int top = 0, bottom = woiheight, left = 0, right = woiwidth;
	float wbgain[4] = { 1,1,1,1 }; // r gr gb b
	int blacklevel[4] = { 64, 64, 64, 64 }; // ��10bit
	float ccm[9] = { 1.568639f,-0.358657f,-0.209982f,-0.191115f,1.646191f,-0.455076f,0.070816f,-0.684568f,1.613751f }; // rgb
	float sensorgain = 16;
	float ispgain = 1;
	float adrcgain = 1;
	float shutter = 6781; // us
	float luxindex = 1;
	float midtonegain = 100;

	//float sensorgain2 = 16;
	//float ispgain2 = 1;
	//float adrcgain2 = 1;
	//float shutter2 = 5409; // us

	//only master
	float sensorgain2 = 16;
	float ispgain2 = 1;
	float adrcgain2 = 1;
	float shutter2 = 6781; // us

	vector<float> expoInit;
	expoInit.push_back(shutter); //init exptime
	expoInit.push_back(sensorgain);  //init adgain
	expoInit.push_back(ispgain);  //init ispgain
	expoInit.push_back(0);    //sofid
	expousureList.push(expoInit);
	expousureraw.push(expoInit);
	expoInit[3] = 1;
	expousureList.push(expoInit);
	expousureraw.push(expoInit);
	expoInit[3] = 2;
	expousureList.push(expoInit);
	expousureraw.push(expoInit);
	expoInit[3] = 3;
	expousureList.push(expoInit);
	expousureraw.push(expoInit);
	expoInit[3] = 4;
	expousureList.push(expoInit);
	expousureraw.push(expoInit);
	expoInit[3] = 5;
	expousureList.push(expoInit);
	expousureraw.push(expoInit);
	/* ae init */
	gxr_ae.min_iso = 100;   // scale 100
	gxr_ae.calib_b_gain = 1500;   // scale 1000
	gxr_ae.calib_g_gain = 1000;
	gxr_ae.calib_r_gain = 1500;
	gxr_ae.atf_mode = (enum ae_antiflicker_mode_t)0;
	// set AE enable
	gxr_ae.ae_enable = 1;
	gxr_ae.cameraId = 0;  //left:0; right:1
	gxr_ae.ae_adgain = sensorgain * ispgain * 100;
	gxr_ae.ae_shutter = shutter;
	gxr_ae.midtones_gain = midtonegain;
	gxr_ae.err_code = 1; //temp simulate flag

	ae_err = ae_initial(&gxr_ae);
	if (ae_err != 0x00) {
		printf("AE init error: %#x\r\n", ae_err);
		return ae_err;
	}

	/* ae2 init */
	gxr_ae_c2.min_iso = 100;   // scale 100
	gxr_ae_c2.calib_b_gain = 1500;   // scale 1000
	gxr_ae_c2.calib_g_gain = 1000;
	gxr_ae_c2.calib_r_gain = 1500;
	gxr_ae_c2.atf_mode = (enum ae_antiflicker_mode_t)0;
	// set AE enable
	gxr_ae_c2.ae_enable = 1;
	gxr_ae_c2.cameraId = 1;  //left:0; right:1
	gxr_ae_c2.ae_adgain = sensorgain2 * ispgain2 * 100;
	gxr_ae_c2.ae_shutter = shutter2;
	gxr_ae_c2.midtones_gain = midtonegain;
	gxr_ae_c2.err_code = 1; //temp simulate flag

	//ae_err = ae_initial(&gxr_ae_c2);
	if (ae_err != 0x00) {
		printf("AE init error: %#x\r\n", ae_err);
		return ae_err;
	}

	/* awb init */
	gxr_awb.awb_set_para.para.awb_calib_data.calib_r_gain = 1000;
	gxr_awb.awb_set_para.para.awb_calib_data.calib_g_gain = 1000;
	gxr_awb.awb_set_para.para.awb_calib_data.calib_b_gain = 1000;
	gxr_awb.tuning_enable = 1;
	awb_err = awb_initial(&gxr_awb);
	if (awb_err != _AL_AWBLIB_SUCCESS) {
		printf("INIT ERROR %x\r\n", (unsigned int)awb_err);
		return awb_err;
	}

	/* ATF INIT*/
	//get sensor info
	gxr_atf.line_time_ns = 6300;   //diffrent with sensors  similar as 1/fps/VST
	gxr_atf.sensor_height = atf_roiheight;
	gxr_atf.sensor_width = atf_roiwidth;
	atf_err = atf_initial(&gxr_atf);
	if (atf_err != 0x00) {
		printf("AE init error: %#x\r\n", atf_err);
		return atf_err;
	}

	raw2bgr_handle->verbose = verbose;
	raw2bgr_handle->rpat = rpat;
	raw2bgr_handle->depth = depth;
	raw2bgr_handle->bpc = bpc;
	raw2bgr_handle->height = woiheight;
	raw2bgr_handle->width = woiwidth;
	raw2bgr_handle->top = top;
	raw2bgr_handle->bottom = bottom;
	raw2bgr_handle->left = left;
	raw2bgr_handle->right = right;
	raw2bgr_handle->wben = wben;
	raw2bgr_handle->expen = expen;
	raw2bgr_handle->atfen = atfen;
	raw2bgr_handle->awbsat = awbsat;
	raw2bgr_handle->awb_blknumx = awb_blknumx;
	raw2bgr_handle->awb_blknumy = awb_blknumy;
	raw2bgr_handle->aesat = aesat;
	raw2bgr_handle->ae_blknumx = ae_blknumx;
	raw2bgr_handle->ae_blknumy = ae_blknumy;
	raw2bgr_handle->atf_roiheight = atf_roiheight;
	raw2bgr_handle->atf_roiwidth = atf_roiwidth;
	memcpy(raw2bgr_handle->blacklevel, blacklevel, sizeof(blacklevel));
	raw2bgr_handle->sensorgain = sensorgain;
	raw2bgr_handle->ispgain = ispgain;
	raw2bgr_handle->adrcgain = adrcgain;
	raw2bgr_handle->shutter = shutter;
	raw2bgr_handle->luxindex = luxindex;
	raw2bgr_handle->lsc_height = lsc_height;
	raw2bgr_handle->lsc_width = lsc_width;
	raw2bgr_handle->lsctable[0] = lsctable;
	raw2bgr_handle->lsctable[1] = lsctable + lsc_height * lsc_width;
	raw2bgr_handle->lsctable[2] = lsctable + lsc_height * lsc_width * 2;
	raw2bgr_handle->lsctable[3] = lsctable + lsc_height * lsc_width * 3;
	raw2bgr_handle->gmtablex = gmtablex;
	raw2bgr_handle->gmtabley = gmtabley;
	raw2bgr_handle->input = input_buffer;
	raw2bgr_handle->output = output_buffer;
	memcpy(raw2bgr_handle->wbgain, wbgain, sizeof(wbgain));
	memcpy(raw2bgr_handle->ccm, ccm, sizeof(ccm));

	//for save ae out, init keep with ini file
	float ae_sensor_gain = sensorgain;
	float ae_shutter = shutter;				 // us
	float ae_out_ispgain = ispgain;
	float ae_lux_result = luxindex;

	float ae_sensor_gain_c2 = sensorgain2;
	float ae_shutter_c2 = shutter2;				 // us
	float ae_out_ispgain_c2 = ispgain2;
	float ae_lux_result_c2 = luxindex;

	LARGE_INTEGER tc;
	QueryPerformanceFrequency(&tc);
	printf("\n qcount %lld\n", tc.QuadPart);
	int sumtime = 0;

	/* raw */
	int frame_num = 0;

	lastexposure[0] = sensorgain * 100.0f * shutter;

	/*raw simulate*/
	int allraw = 2;
	string pathName, fileName;
	char file[512];
	char* file_name;
	int filecount = 1;
	int convcnt = 1;
	//multi camera
	/*if (allraw == 1)
	{
		//loop dir raw to simu
		intptr_t hFile1 = 0;
		intptr_t hFile2 = 0;
		struct _finddata_t fileInfo1;
		struct _finddata_t fileInfo2;
		string path1 = "D:\\CAM2hand\\testWdrChar\\target48";
		string path2 = "D:\\CAM2hand\\testWdrChar\\target48";
		//string path1 = "D:\\CAM2hand\\otestresim\\nightplane";
		string rawpath = path1;
		hFile1 = _findfirst(pathName.assign(path1).append("\\*.raw").c_str(), &fileInfo1);
		hFile2 = _findfirst(pathName.assign(path2).append("\\*.raw").c_str(), &fileInfo2);
		if (hFile1 == -1) {
			std::cout << "there is no flie to read" << endl;
			return 1;
		}

		//filename sort

		fileList file2[2000];
		memset(file2, 0, sizeof(file2));
		int filenNum = 0;
		do {
			strncpy(file2[filenNum].filename, fileInfo2.name, 260);
			int idx = 0;
			string filenametemp = fileInfo2.name;
			idx = stof(filenametemp.substr(filenametemp.find("CAM2_[") + 6, 4));
			file2[filenNum].fileidx = idx;
			filenNum++;
		} while (!_findnext(hFile2, &fileInfo2));
		_findclose(hFile2);

		qsort(file2, filenNum, sizeof(fileList), sortByIdx);
		//mkdir new path file to save aec_raw
		string subffix = "\\";

		int fileCountinNum = 0;
		if (_access(path1.c_str(), 0) == -1)
		{
			_mkdir(path1.c_str());
		}
		do {

			//gxr_ae————————————————————————————————
			//————————————————————————————————
			printf("\ndebug start gxr_ae-------------------------------------\n");

			fileName = path1 + "\\" + fileInfo1.name;
			if (filecount > 1)
			{
				input_buffer = (unsigned short*)malloc(height * width * sizeof(unsigned short));
				raw2bgr_handle->input = input_buffer;
			}



			strcpy(file, fileName.c_str());
			file_name = file;
			FILE* fid = fopen(file_name, "rb");
			fread(input_buffer, sizeof(unsigned short), height * width, fid);
			fclose(fid);

			if (filecount > 1)
			{
				string filename = fileInfo1.name;
				float rawsensorgain = 1.0f;
				float rawexptime = 1.0f;
				float rawispgain = 1.0f;

				rawsensorgain = stof(filename.substr(filename.find("SenG[") + 5, 5));
				string timetemp = filename.substr(filename.find("Shut[") + 5, 5);
				//rawsensorgain = stof(filename.substr(filename.find("SensorGain[") + 11, 5));
				//string timetemp = filename.substr(filename.find("Shutter[") + 8, 5);


				if (timetemp.find("[") != string::npos)
				{
					timetemp = timetemp.substr(0, timetemp.find("["));
				}

				rawexptime = stof(timetemp);

				printf("debug readraw sensorgain %f  exptime %f\n", rawsensorgain, rawexptime);

				missGain = actualexposure[gxr_ae.cameraId] / (rawsensorgain * rawexptime * 100);
				rawModify(input_buffer, missGain);
			}

			printf("debug  saveraw filecount %d readpath %s\n", filecount, file_name);
			//if (1)
			//{
				char* savePath;
				char rtemp[20];
				subffix = ".raw";
				string replaceChar;
                sprintf(rtemp,"_new.raw");
                replaceChar = rtemp;
				string fileName0 = path1 + "\\" + "test4centerw\\" + fileInfo1.name;
				int pos1 = fileName0.find(subffix);
				char savefile[512];
                strcpy(savefile, fileName0.replace(pos1, subffix.length(), replaceChar).c_str());
				printf("debug savepath %s\n", savefile);
				savePath = savefile;
				saveRaw(input_buffer, savePath);
			//}

			gxr_ae.cameraId = 0;

			//update some isp intput param every frame 
			printf("debug curisp input sensorgain %f  exptime %f  ispgain %f\n", sensorgain, shutter, ispgain);
			raw2bgr_handle->sensorgain = sensorgain;
			raw2bgr_handle->ispgain = ispgain;
			raw2bgr_handle->adrcgain = adrcgain;
			raw2bgr_handle->shutter = shutter;

			// 2a stats <- isp
			gxr_sraw2bgr_run_all(raw2bgr_handle);
			memcpy(awbstats.data(), raw2bgr_handle->handle[2], awb_blknumx * awb_blknumy * 5 * sizeof(int));
			memcpy(aestats.data(), raw2bgr_handle->handle[3], ae_blknumx * ae_blknumy * 8 * sizeof(int));
			memcpy(histgram.data(), raw2bgr_handle->handle[4], 256 * sizeof(int));

			ofstream ofile;
			ofile.open("aestats.txt", ios::out);
			for (int i = 0; i < ae_blknumx * ae_blknumy * 8 * sizeof(int); i++)
			{
				ofile << aestats.data()[i] << endl;
			}
			ofile.close();
			ofstream ohfile;
			ohfile.open("aehist.txt", ios::out);
			for (int i = 0; i < 256 * sizeof(int); i++)
			{
				ohfile << histgram.data()[i] << endl;
			}
			ohfile.close();
			// aerun update perframe
			gxr_ae.frameId = frame_num;
			gxr_ae.statsBankNum = ae_blknumy;
			gxr_ae.statsBolckNum = ae_blknumx;
			gxr_ae.ae_stats = aestats.data();			//get from isp aestats
			gxr_ae.yhis_stats = histgram.data();		// get from isp yhis
			gxr_ae.sensorgain = (int)sensorgain * ispgain * 100;  //scale 
			gxr_ae.shutter = (int)shutter;
			gxr_ae.midtones_gain = midtonegain;
			gxr_ae.atf_mode = ANTIFLICKER_OFF;  // DEFAULT OFF; OR GET FROM ATF  ANTIFLICKER_50HZ


			//set debug tag  --> UI TAG
			gxr_ae.debug_level = Debug;   //default: Log_OFF = 0
			//gxr_ae.debug_level = Log_OFF;   //default: Log_OFF = 0
			gxr_ae.save_to_file = 0;
			gxr_ae.tuning_enable = 1;

			//if (filecount % 3 != 0)
			//{
			LARGE_INTEGER t1, t2;
			QueryPerformanceCounter(&t1);
			ae_err = ae_run(&gxr_ae);
			QueryPerformanceCounter(&t2);

			//}


			if (ae_err != 0x00) {
				printf("AE run error: %#x\r\n", ae_err);
				return ae_err;
			}
			// get ae out and save //write ae out to sensor and ispgain update while ae sensor  param effect

			ae_shutter = (float)gxr_ae.ae_shutter;
			ae_sensor_gain = min(gxr_ae.ae_adgain / 100.0f, 16.0f);   //ae out has scale 100
			ae_out_ispgain = max(1.0f, gxr_ae.ae_adgain / 16 / 100);  //sensor adgain max is 16
			ae_lux_result = gxr_ae.ae_lux_result / 1000.0f;  // lv scale 1000

			printf("[alAELib] Process[%02d]: bdYmean %.2f, Lux %ld ExpT %.2f(us), Gain %.2f, converge %d, isp %f\n", \
				frame_num, gxr_ae.Ymean, gxr_ae.ae_lux_result, gxr_ae.ae_shutter, \
				gxr_ae.ae_adgain, gxr_ae.ae_converged, ae_out_ispgain);

			//printf("bgbv: %ld nextbv: %ld\n", gxr_ae.bgbv, gxr_ae.nextbv);
			printf("bgY : %d \n", gxr_ae.exif_info.bgYmean_8bit);
			//update lux_index to isp current frame
			raw2bgr_handle->luxindex = ae_lux_result;

			// ATF
			gxr_atf.atf_stats = atfstats.data();
			gxr_atf.gain = sensorgain * 100;
			gxr_atf.exposure_time = shutter;
			//gxr_atf.average_value = gxr_ae.Ymean;
			gxr_atf.average_value = 3825;
			//atf_err = atf_run(&gxr_atf);
			if (atf_err != 0x00) {
				printf("AFD run error: %#x\r\n", atf_err);
				return atf_err;
			}
			printf("[%02d] [alAFDLib] output result => flag_enable : %d, flag_bending : %d, afd_mode : %d, afd_mode_stable : %d\n",
				frame_num, gxr_atf.atf_output.flag_enable, gxr_atf.atf_output.flag_bending, gxr_atf.atf_output.atf_mode, gxr_atf.atf_output.atf_mode_stable);


			//awb stats <- isp
			gxr_awb.awb_stats = awbstats.data();
			//for (int i = 0; i < 1000; i++) {
			//	printf("AWB stats %#d\r\n", awbstats[i]);
			//}

			//awbrun input <- ae
			gxr_awb.awb_set_para.type = ALAWB_SET_PARAM_UPDATE_AE_REPORT;
			gxr_awb.awb_set_para.para.ae_report_update.bv = gxr_ae.nextbv;
			gxr_awb.awb_set_para.para.ae_report_update.non_comp_bv = gxr_ae.bgbv;
			gxr_awb.awb_set_para.para.ae_report_update.iso = gxr_ae.iso;
			gxr_awb.awb_set_para.para.ae_report_update.midtones_gain = gxr_ae.midtones_gain;
			gxr_awb.awb_set_para.para.ae_report_update.shadows_gain = gxr_ae.shadows_gain;

			//printf("awb proc \n");
			gxr_awb.debug_level = AWBDebug;   //default: Log_OFF = 0
			//gxr_ae.debug_level = Log_OFF;   //default: Log_OFF = 0
			gxr_awb.save_to_file = 1;
			awb_err = awb_run(&gxr_awb);

			if (awb_err != 0x00) {
				printf("RUN ERROR %x\r\n", (unsigned int)awb_err);
				return awb_err;
			}

			for (int i = 0; i < 884; i++)
			{
				gxr_awb.awb_output.final_lsc[i] = 1.0f;
			}

			gxr_awb.awb_output.wbgain.r_gain = 494;
			gxr_awb.awb_output.wbgain.g_gain = 256;
			gxr_awb.awb_output.wbgain.b_gain = 488;

			printf("[alAWBLib] CT: %3d\r\n", (int)gxr_awb.awb_output.color_temp);
			printf("[alAWBLib] WB Gain %3d %3d %3d\r\n", gxr_awb.awb_output.wbgain.r_gain, gxr_awb.awb_output.wbgain.g_gain, gxr_awb.awb_output.wbgain.b_gain);
			printf("[alAWBLib] CCM %3f %3f %3f\r\n", gxr_awb.awb_output.final_CCM[0], gxr_awb.awb_output.final_CCM[1], gxr_awb.awb_output.final_CCM[2]);
			printf("[alAWBLib] final_lsc %3f %3f \r\n", gxr_awb.awb_output.final_lsc[13 * 17], gxr_awb.awb_output.final_lsc[3 * 13 * 17 - 1]);

			//ispinput <- 2a
			wbgain[0] = gxr_awb.awb_output.wbgain.r_gain / 100.0f;
			wbgain[1] = gxr_awb.awb_output.wbgain.g_gain / 100.0f;
			wbgain[2] = gxr_awb.awb_output.wbgain.g_gain / 100.0f;
			wbgain[3] = gxr_awb.awb_output.wbgain.b_gain / 100.0f;
			memcpy(raw2bgr_handle->wbgain, wbgain, sizeof(wbgain));
			memcpy(raw2bgr_handle->ccm, gxr_awb.awb_output.final_CCM, sizeof(gxr_awb.awb_output.final_CCM));
			raw2bgr_handle->lsctable[0] = gxr_awb.awb_output.final_lsc;
			raw2bgr_handle->lsctable[1] = gxr_awb.awb_output.final_lsc + lsc_height * lsc_width;
			raw2bgr_handle->lsctable[2] = gxr_awb.awb_output.final_lsc + lsc_height * lsc_width * 2;
			raw2bgr_handle->lsctable[3] = gxr_awb.awb_output.final_lsc + lsc_height * lsc_width * 3;
			

			gxr_sraw2bgr_run_all(raw2bgr_handle);
			char ppmtemp[300];
			string ppmName;
			ppmName = path1 + "\\test4centerw\\ppm\\";
			sprintf(ppmtemp, "%scam%d_%d.ppm", ppmName.c_str(), gxr_ae.cameraId, filecount);
			ppmWrite(ppmtemp, output_buffer, height, width);
			printf("debug saveppm\n");



			//if (filecount % 3 == 0)
			//{
			//    allConverge[gxr_ae.cameraId] = gxr_ae.ae_converged;
			//    actualexposure[gxr_ae.cameraId] = gxr_ae.ae_shutter * ae_sensor_gain * 100;
			//    
			//    sensorgain = ae_sensor_gain;
			//    shutter = gxr_ae.ae_shutter;
			//    ispgain = ae_out_ispgain;
			//    
			//}
			
			vector<float> expoInit;
			expoInit.push_back(gxr_ae.ae_shutter); //init exptime
			expoInit.push_back(ae_sensor_gain);  //init adgain
			expoInit.push_back(ae_out_ispgain);  //init ispgain
			expoInit.push_back(filecount * 1.0f);    //sofid
			expousureList.push(expoInit);

			vector<float> expoSOF;
			expoSOF = expousureList.front();
			expousureList.pop();
			allConverge[gxr_ae.cameraId] = gxr_ae.ae_converged;
			actualexposure[gxr_ae.cameraId] = expoSOF[0] * expoSOF[1] * 100;

			sensorgain = expoSOF[1];
			shutter = expoSOF[0];
			ispgain = expoSOF[2];

			printf("debug expsof  shutter %f  sensorgain %f ispgain %f", expoSOF[0], expoSOF[1], expoSOF[2]);
			
            printf("debug converge %d\n", allConverge[0]);
			
			printf("-----------------------end ------------------------------");

			free(input_buffer);



			//gxr_ae_c2————————————————————————————————————
			//—————————————————————————————————————————
			printf("\ndebug start gxr_ae_c2------------------------------------\n");

			string fileName2 = path2 + "\\" + file2[fileCountinNum].filename;

			input_buffer = (unsigned short*)malloc(height * width * sizeof(unsigned short));
			raw2bgr_handle->input = input_buffer;
			



			strcpy(file, fileName2.c_str());
			file_name = file;
			FILE* fid2 = fopen(file_name, "rb");
			fread(input_buffer, sizeof(unsigned short), height * width, fid2);
			fclose(fid2);

			//only master
			if (filecount == 1)
			{
				string filename = file2[fileCountinNum].filename;
				float rawsensorgain = 1.0f;
				float rawexptime = 1.0f;
				float rawispgain = 1.0f;

				rawsensorgain = stof(filename.substr(filename.find("SenG[") + 5, 5));
				string timetemp = filename.substr(filename.find("Shut[") + 5, 5);
				//rawsensorgain = stof(filename.substr(filename.find("SensorGain[") + 11, 5));
				//string timetemp = filename.substr(filename.find("Shutter[") + 8, 5);


				if (timetemp.find("[") != string::npos)
				{
					timetemp = timetemp.substr(0, timetemp.find("["));
				}

				rawexptime = stof(timetemp);

				printf("debug readraw2 sensorgain %f  exptime %f\n", rawsensorgain, rawexptime);

				missGain = sensorgain2 * shutter2 / (rawsensorgain * rawexptime);
				rawModify(input_buffer, missGain);
			}


			if (filecount > 1)
			{
				string filename = file2[fileCountinNum].filename;
				float rawsensorgain = 1.0f;
				float rawexptime = 1.0f;
				float rawispgain = 1.0f;

				rawsensorgain = stof(filename.substr(filename.find("SenG[") + 5, 5));
				string timetemp = filename.substr(filename.find("Shut[") + 5, 5);
				//rawsensorgain = stof(filename.substr(filename.find("SensorGain[") + 11, 5));
				//string timetemp = filename.substr(filename.find("Shutter[") + 8, 5);


				if (timetemp.find("[") != string::npos)
				{
					timetemp = timetemp.substr(0, timetemp.find("["));
				}

				rawexptime = stof(timetemp);

				printf("debug readraw2 sensorgain %f  exptime %f\n", rawsensorgain, rawexptime);

				missGain = actualexposure[gxr_ae_c2.cameraId] / (rawsensorgain * rawexptime * 100);
				rawModify(input_buffer, missGain);
			}

			printf("debug saveraw2 filecount %d  readpath %s", filecount, file_name);
			//if (1)
			//{
				char* savePath1;
				char rtemp1[20];
				subffix = ".raw";
				string replaceChar1;
				sprintf(rtemp1, "_new.raw");
				replaceChar1 = rtemp1;
				string fileName1 = path2 + "\\" + "test4centerw\\" + file2[fileCountinNum].filename;
				int pos2 = fileName1.find(subffix);
				char savefile1[512];
				strcpy(savefile1, fileName1.replace(pos2, subffix.length(), replaceChar1).c_str());
				printf("debug savepath2 %s", savefile1);
				savePath1 = savefile1;
				saveRaw(input_buffer, savePath1);
			//}
			gxr_ae_c2.cameraId = 1;

			//update some isp intput param every frame 
			printf("debug c2 curisp input sensorgain %f  exptime %f  ispgain %f\n", sensorgain2, shutter2, ispgain2);
			raw2bgr_handle->sensorgain = sensorgain2;
			raw2bgr_handle->ispgain = ispgain2;
			raw2bgr_handle->adrcgain = adrcgain2;
			raw2bgr_handle->shutter = shutter2;

			// 2a stats <- isp
			gxr_sraw2bgr_run_all(raw2bgr_handle);
			memcpy(awbstats.data(), raw2bgr_handle->handle[2], awb_blknumx * awb_blknumy * 5 * sizeof(int));
			memcpy(aestats.data(), raw2bgr_handle->handle[3], ae_blknumx * ae_blknumy * 8 * sizeof(int));
			memcpy(histgram.data(), raw2bgr_handle->handle[4], 256 * sizeof(int));

			// aerun update perframe
			gxr_ae_c2.frameId = frame_num;
			gxr_ae_c2.statsBankNum = ae_blknumy;
			gxr_ae_c2.statsBolckNum = ae_blknumx;
			gxr_ae_c2.ae_stats = aestats.data();			//get from isp aestats
			gxr_ae_c2.yhis_stats = histgram.data();		// get from isp yhis
			gxr_ae_c2.sensorgain = (int)sensorgain2 * ispgain2 * 100;  //scale 
			gxr_ae_c2.shutter = (int)shutter;
			gxr_ae_c2.midtones_gain = midtonegain;
			gxr_ae_c2.atf_mode = ANTIFLICKER_OFF;  // DEFAULT OFF; OR GET FROM ATF  ANTIFLICKER_50HZ


			//set debug tag  --> UI TAG
			gxr_ae_c2.debug_level = Debug;   //default: Log_OFF = 0
			//gxr_ae_c2.debug_level = Log_OFF;   //default: Log_OFF = 0
			gxr_ae_c2.save_to_file = 0;
			gxr_ae_c2.tuning_enable = 1;


			LARGE_INTEGER t21, t22;
			QueryPerformanceCounter(&t21);
			ae_err = ae_run(&gxr_ae_c2);
			QueryPerformanceCounter(&t22);
			sumtime = sumtime + t22.QuadPart - t21.QuadPart + t2.QuadPart - t1.QuadPart;

			ae_shutter_c2 = (float)gxr_ae_c2.ae_shutter;
			ae_sensor_gain_c2 = min(gxr_ae_c2.ae_adgain / 100.0f, 16.0f);   //ae out has scale 100
			ae_out_ispgain_c2 = max(1.0f, gxr_ae_c2.ae_adgain / 16 / 100);  //sensor adgain max is 16
			ae_lux_result_c2 = gxr_ae_c2.ae_lux_result / 1000.0f;  // lv scale 1000

			printf("[alAELib] Process c2 [%02d]: bdYmean %.2f, Lux %ld ExpT %.2f(us), Gain %.2f, converge %d, isp %f\n", \
				frame_num, gxr_ae_c2.Ymean, gxr_ae_c2.ae_lux_result, gxr_ae_c2.ae_shutter, \
				gxr_ae_c2.ae_adgain, gxr_ae_c2.ae_converged, ae_out_ispgain_c2);

			vector<float> expoInit2;
			expoInit2.push_back(gxr_ae_c2.ae_shutter); //init exptime
			expoInit2.push_back(ae_sensor_gain_c2);  //init adgain
			expoInit2.push_back(ae_out_ispgain_c2);  //init ispgain
			expoInit2.push_back(filecount * 1.0f);    //sofid
			expousureList2.push(expoInit2);

			vector<float> expoSOF2;
			expoSOF2 = expousureList2.front();
			expousureList2.pop();
			allConverge[gxr_ae_c2.cameraId] = gxr_ae_c2.ae_converged;
			actualexposure[gxr_ae_c2.cameraId] = expoSOF2[0] * expoSOF2[1] * 100;

			sensorgain2 = expoSOF2[1];
			shutter2 = expoSOF2[0];
			ispgain2 = expoSOF2[2];
			gxr_sraw2bgr_run_all(raw2bgr_handle);

			char ppmtemp1[300];
			string ppmName1;
			ppmName1 = path2 + "\\test4centerw\\ppm\\";
			sprintf(ppmtemp1, "%scam%d_%d.ppm", ppmName1.c_str(), gxr_ae_c2.cameraId, filecount);
			ppmWrite(ppmtemp1, output_buffer, height, width);
			printf("debug c2 saveppm\n");

			free(input_buffer);
			printf("debug c2 11111 expsof  shutter %f  sensorgain %f ispgain %f", expoSOF2[0], expoSOF2[1], expoSOF2[2]);

			filecount++;
			fileCountinNum++;

			printf("debug converge %d\n", allConverge[1]);

			printf("-----------------------end ------------------------------");
			printf("\n debug sumtime %d",sumtime);
		} while (!_findnext(hFile1, &fileInfo1) && fileCountinNum <= filenNum); //while (!allConverge[0] || !allConverge[1]);    //_findnext() intptr_t notlong
		_findclose(hFile1);
		
	}
	*/

    
	if (allraw == 2)
	{
		//loop dir raw to simu
		intptr_t hFile1 = 0;
		intptr_t hFile2 = 0;
		struct _finddata_t fileInfo1;
		//struct _finddata_t fileInfo2;
		//string path1 = "D:\\CAM2hand\\CAM1";
		//string path2 = "D:\\CAM2hand\\CAM2";
		string path1 = "D:\\debugtest\\0522\\lab\\100-700\\raw";
		string rawpath = path1;
		hFile1 = _findfirst(pathName.assign(path1).append("\\*.raw").c_str(), &fileInfo1);
		//hFile2 = _findfirst(pathName.assign(path2).append("\\*.raw").c_str(), &fileInfo2);
		if (hFile1 == -1) {
			std::cout << "there is no flie to read" << endl;
			return 1;
		}

		//filename sort

		fileList file1[2000];
		memset(file1, 0, sizeof(file1));
		int filenNum = 0;
		do {
			strncpy(file1[filenNum].filename, fileInfo1.name, 260);
			int idx = 0;
			string filenametemp = fileInfo1.name;
			//idx = stof(filenametemp.substr(filenametemp.find("Frame_") + 6, 1));
			idx = stof(filenametemp.substr(filenametemp.find("CAM2_[") + 6, 4));
			idx++;
			file1[filenNum].fileidx = idx;
			filenNum++;
		} while (!_findnext(hFile1, &fileInfo1));
		_findclose(hFile1);

		qsort(file1, filenNum, sizeof(fileList), sortByIdx);
		//mkdir new path file to save aec_raw
		string subffix = "\\";

		int fileCountinNum = 0;
		if (_access(path1.c_str(), 0) == -1)
		{
			_mkdir(path1.c_str());
		}
		do {

			//gxr_ae————————————————————————————————
			//————————————————————————————————
			printf("\ndebug start gxr_ae-------------------------------------\n");

			fileName = path1 + "\\" + file1[fileCountinNum].filename;
			if (filecount > 1)
			{
				input_buffer = (unsigned short*)malloc(height * width * sizeof(unsigned short));
				crop_input_buffer = (unsigned short*)malloc(woiheight * woiwidth * sizeof(unsigned short));
				raw2bgr_handle->input = input_buffer;
			}



			strcpy(file, fileName.c_str());
			file_name = file;
			FILE* fid = fopen(file_name, "rb");
			fread(input_buffer, sizeof(unsigned short), height * width, fid);
			fclose(fid);


			int j = 0;
			for (int i = 0; i < height * width; i++)
			{
				//if (checkinwoi(i))
				//{
					//crop_input_buffer[j] = input_buffer[i];
			        //j++;
				//}

			}
			//raw2bgr_handle->input = crop_input_buffer;
			if (filecount == 1)
			{
				string filename = file1[fileCountinNum].filename;
				float rawsensorgain = 1.0f;
				float rawexptime = 1.0f;
				float rawispgain = 1.0f;

				rawsensorgain = stof(filename.substr(filename.find("SenG[") + 5, 5));
				string timetemp = filename.substr(filename.find("Shut[") + 5, 5);
				//rawsensorgain = stof(filename.substr(filename.find("SensorGain[") + 11, 5));
				//string timetemp = filename.substr(filename.find("Shutter[") + 8, 5);


				if (timetemp.find("[") != string::npos)
				{
					timetemp = timetemp.substr(0, timetemp.find("["));
				}

				rawexptime = stof(timetemp);

				//rawsensorgain = 4;
				//rawexptime = 7000;

				vector<float> expousureSetRaw;
				expousureSetRaw = expousureraw.front();
				expousureraw.pop();

				vector<float> expousureReadRaw;
				expousureReadRaw.push_back(rawexptime); //init exptime
				expousureReadRaw.push_back(rawsensorgain);  //init adgain
				expousureReadRaw.push_back(rawispgain);  //init ispgain
				expousureReadRaw.push_back(0);    //sofid
				expousureraw.push(expousureReadRaw);
                printf("debug readraw sensorgain %f  exptime %f\n", rawsensorgain, rawexptime);
				rawexptime = expousureSetRaw[0];
				rawsensorgain = expousureSetRaw[1];
				printf("debug setraw sensorgain %f  exptime %f\n", rawsensorgain, rawexptime);
				

				missGain = sensorgain * shutter / (rawsensorgain * rawexptime);
				rawModify(input_buffer, missGain);
			}

			if (filecount > 1)
			{
				string filename = file1[fileCountinNum].filename;
				float rawsensorgain = 1.0f;
				float rawexptime = 1.0f;
				float rawispgain = 1.0f;

				rawsensorgain = stof(filename.substr(filename.find("SenG[") + 5, 5));
				string timetemp = filename.substr(filename.find("Shut[") + 5, 5); 

				//rawsensorgain = stof(filename.substr(filename.find("SensorGain[") + 11, 5));
				//string timetemp = filename.substr(filename.find("Shutter[") + 8, 5);


				if (timetemp.find("[") != string::npos)
				{
					timetemp = timetemp.substr(0, timetemp.find("["));
				}

				rawexptime = stof(timetemp);


				//rawsensorgain = 4;
				//rawexptime = 7000;

				vector<float> expousureSetRaw;
				expousureSetRaw = expousureraw.front();
				expousureraw.pop();
				vector<float> expousureReadRaw;
				expousureReadRaw.push_back(rawexptime); //init exptime
				expousureReadRaw.push_back(rawsensorgain);  //init adgain
				expousureReadRaw.push_back(ispgain);  //init ispgain
				expousureReadRaw.push_back(0);    //sofid
				expousureraw.push(expousureReadRaw);
				printf("debug readraw sensorgain %f  exptime %f\n", rawsensorgain, rawexptime);
				rawexptime = expousureSetRaw[0];
				rawsensorgain = expousureSetRaw[1];
				printf("debug setraw sensorgain %f  exptime %f\n", rawsensorgain, rawexptime);

				missGain = actualexposure[gxr_ae.cameraId] / (rawsensorgain * rawexptime * 100);
				rawModify(input_buffer, missGain);
			}


			printf("debug  saveraw filecount %d readpath %s\n", filecount, file_name);
			//if (1)
			//{
			char* savePath;
			char rtemp[20];
			subffix = ".raw";
			string replaceChar;
			sprintf(rtemp, "_new.raw");
			replaceChar = rtemp;
			string fileName0 = path1 + "\\" + "newraw\\" + file1[fileCountinNum].filename;
			int pos1 = fileName0.find(subffix);
			char savefile[512];
			strcpy(savefile, fileName0.replace(pos1, subffix.length(), replaceChar).c_str());
			printf("debug savepath %s\n", savefile);
			savePath = savefile;
			//saveRaw(input_buffer, savePath);
			//}

			gxr_ae.cameraId = 0;

			//update some isp intput param every frame 
			printf("debug curisp input sensorgain %f  exptime %f  ispgain %f\n", sensorgain, shutter, ispgain);
			raw2bgr_handle->sensorgain = sensorgain;
			raw2bgr_handle->ispgain = ispgain;
			raw2bgr_handle->adrcgain = adrcgain;
			raw2bgr_handle->shutter = shutter;

			// 2a stats <- isp
			gxr_sraw2bgr_run_all(raw2bgr_handle);
			memcpy(awbstats.data(), raw2bgr_handle->handle[2], awb_blknumx * awb_blknumy * 5 * sizeof(int));
			memcpy(aestats.data(), raw2bgr_handle->handle[3], ae_blknumx * ae_blknumy * 8 * sizeof(int));
			memcpy(histgram.data(), raw2bgr_handle->handle[4], 256 * sizeof(int));


			//typedef struct IspSoftIspAeStatusOut
			//{
			//	uint32_t         sensor_shutter_us;
			//	uint32_t         sensor_adgain;
			//	uint32_t         stats_woi_height;
			//	uint32_t         stats_woi_width;
			//	uint16_t         ae_stats_blockY;  //ae
			//	uint16_t         ae_stats_blockX;
			//	uint32_t         ae_stats[8 * 36 * 24];  // max size 8*36*24
			//	uint32_t         ae_hist[256];  // max size
			//} IspSoftIspAeStatusOut;
			//IspSoftIspAeStatusOut aehulkstats;
			//aehulkstats.sensor_shutter_us = 90;
			//aehulkstats.sensor_adgain = 100;
			//aehulkstats.stats_woi_height = raw2bgr_handle->height;
			//aehulkstats.stats_woi_width = raw2bgr_handle->width;
			//aehulkstats.ae_stats_blockY = raw2bgr_handle->ae_blknumy;
			//aehulkstats.ae_stats_blockX = raw2bgr_handle->ae_blknumx;
			//memset(aehulkstats.ae_stats, 0, sizeof(aehulkstats.ae_stats));
			////memcpy(aehulkstats.ae_stats, aestats.data(), ae_blknumx* ae_blknumy * 8 * sizeof(int));
			//FILE* fidtmpaestatshulk = fopen("rlgcropispaeStats.txt", "rb");
			//for (int i = 0; i < ae_blknumx * ae_blknumy * 8; i++)
			//{
			//	fscanf(fidtmpaestatshulk, "%d\n", &aehulkstats.ae_stats[i]);
			//}
			//fclose(fidtmpaestatshulk);

			//memset(aehulkstats.ae_hist,0,sizeof(aehulkstats.ae_hist));
			////memcpy(aehulkstats.ae_hist, histgram.data(), 256 * sizeof(int));
			//FILE* fidtmpaehisthulk = fopen("rlgcropispaeHist.txt", "rb");
			//for (int i = 0; i < 256; i++)
			//{
			//	fscanf(fidtmpaehisthulk, "%d\n", &aehulkstats.ae_hist[i]);
			//}
			//fclose(fidtmpaehisthulk);

			//FILE* fileaestats = fopen("ISPAeStatusOutfakeshutter90.bin", "wb");
			//fwrite(&aehulkstats,sizeof(aehulkstats),1, fileaestats);
			//fclose(fileaestats);

			//FILE* fileispaestats = fopen("rlgcropispae.txt", "w");
			//fprintf(fileispaestats, "sensor_shutter_us = %d\n", (int)raw2bgr_handle->shutter);
			//fprintf(fileispaestats, "sensor_adgain = %d\n", (int)raw2bgr_handle->sensorgain * 100);
			//fprintf(fileispaestats, "stats_woi_height = %d\n", raw2bgr_handle->height);
			//fprintf(fileispaestats, "stats_woi_width = %d\n", raw2bgr_handle->width);
			//fprintf(fileispaestats, "ae_stats_blockY = %d\n", raw2bgr_handle->ae_blknumy);
			//fprintf(fileispaestats, "ae_stats_blockX = %d\n", raw2bgr_handle->ae_blknumx);
			//for (int i = 0; i < ae_blknumx * ae_blknumy * 8; i++)
			//{
			//	fprintf(fileispaestats, "ae_stats = %d\n", aestats.data()[i]);
			//}
			//for (int i = 0; i < 256; i++)
			//{
			//	fprintf(fileispaestats, "ae_hist = %d\n", histgram.data()[i]);
			//}
			//fclose(fileispaestats);

			//FILE* fileawbisp = fopen("rlgcropispawb.txt", "w");
			//fprintf(fileawbisp, "stats_woi_height = %d\n", raw2bgr_handle->height);
			//fprintf(fileawbisp, "stats_woi_width = %d\n", raw2bgr_handle->width);
			//fprintf(fileawbisp, "awb_stats_blockY = %d\n", raw2bgr_handle->awb_blknumy);
			//fprintf(fileawbisp, "awb_stats_blockX = %d\n", raw2bgr_handle->awb_blknumx);
			//for (int i = 0; i < awb_blknumx * awb_blknumy * 5; i++)
			//{
			//	fprintf(fileawbisp, "awb_stats = %d\n", awbstats.data()[i]);
			//}
			//fclose(fileawbisp);

			// aerun update perframe
			gxr_ae.frameId = frame_num;
			gxr_ae.statsBankNum = ae_blknumy;
			gxr_ae.statsBolckNum = ae_blknumx;
			gxr_ae.ae_stats = aestats.data();			//get from isp aestats
			gxr_ae.yhis_stats = histgram.data();		// get from isp yhis
			gxr_ae.sensorgain = (int)sensorgain * ispgain * 100;  //scale 
			gxr_ae.shutter = (int)shutter;
			gxr_ae.midtones_gain = midtonegain;
			gxr_ae.atf_mode = ANTIFLICKER_OFF;  // DEFAULT OFF; OR GET FROM ATF  ANTIFLICKER_50HZ


			//set debug tag  --> UI TAG
			gxr_ae.debug_level = Debug;   //default: Log_OFF = 0
			//gxr_ae.debug_level = Log_OFF;   //default: Log_OFF = 0
			gxr_ae.save_to_file = 0; 
			gxr_ae.tuning_enable = 1;

			//if (filecount % 3 != 0)
			//{
			LARGE_INTEGER t1, t2;
			QueryPerformanceCounter(&t1);
			ae_err = ae_run(&gxr_ae);
			QueryPerformanceCounter(&t2);
			//}
			
			

			if (ae_err != 0x00) {
				printf("AE run error: %#x\r\n", ae_err);
				return ae_err;
			}
			// get ae out and save //write ae out to sensor and ispgain update while ae sensor  param effect

			ae_shutter = (float)gxr_ae.ae_shutter;
			ae_sensor_gain = min(gxr_ae.ae_adgain / 100.0f, 16.0f);   //ae out has scale 100
			ae_out_ispgain = max(1.0f, gxr_ae.ae_adgain / 16 / 100);  //sensor adgain max is 16
			ae_lux_result = gxr_ae.ae_lux_result / 1000.0f;  // lv scale 1000

			printf("[alAELib] Process[%02d]: bdYmean %.2f, Lux %ld ExpT %.2f(us), Gain %.2f, converge %d, isp %f\n", \
				frame_num, gxr_ae.Ymean, gxr_ae.ae_lux_result, gxr_ae.ae_shutter, \
				gxr_ae.ae_adgain, gxr_ae.ae_converged, ae_out_ispgain);

			//printf("bgbv: %ld nextbv: %ld\n", gxr_ae.bgbv, gxr_ae.nextbv);
			printf("bgY : %d \n", gxr_ae.exif_info.bgYmean_8bit);
			//update lux_index to isp current frame
			raw2bgr_handle->luxindex = ae_lux_result;

			// ATF
			gxr_atf.atf_stats = atfstats.data();
			gxr_atf.gain = sensorgain * 100;
			gxr_atf.exposure_time = shutter;
			//gxr_atf.average_value = gxr_ae.Ymean;
			gxr_atf.average_value = 3825;
			//atf_err = atf_run(&gxr_atf);
			if (atf_err != 0x00) {
				printf("AFD run error: %#x\r\n", atf_err);
				return atf_err;
			}
			printf("[%02d] [alAFDLib] output result => flag_enable : %d, flag_bending : %d, afd_mode : %d, afd_mode_stable : %d\n",
				frame_num, gxr_atf.atf_output.flag_enable, gxr_atf.atf_output.flag_bending, gxr_atf.atf_output.atf_mode, gxr_atf.atf_output.atf_mode_stable);


			//awb stats <- isp
			gxr_awb.awb_stats = awbstats.data();
			//for (int i = 0; i < 1000; i++) {
			//	printf("AWB stats %#d\r\n", awbstats[i]);
			//}

			//awbrun input <- ae
			gxr_awb.awb_set_para.type = ALAWB_SET_PARAM_UPDATE_AE_REPORT;
			gxr_awb.awb_set_para.para.ae_report_update.bv = gxr_ae.nextbv;
			gxr_awb.awb_set_para.para.ae_report_update.non_comp_bv = gxr_ae.bgbv;
			gxr_awb.awb_set_para.para.ae_report_update.iso = gxr_ae.iso;
			gxr_awb.awb_set_para.para.ae_report_update.midtones_gain = gxr_ae.midtones_gain;
			gxr_awb.awb_set_para.para.ae_report_update.shadows_gain = gxr_ae.shadows_gain;

			//printf("awb proc \n");
			gxr_awb.debug_level = AWBDebug;   //default: Log_OFF = 0
			//gxr_ae.debug_level = Log_OFF;   //default: Log_OFF = 0
			gxr_awb.save_to_file = 1;
			awb_err = awb_run(&gxr_awb);

			if (awb_err != 0x00) {
				printf("RUN ERROR %x\r\n", (unsigned int)awb_err);
				return awb_err;
			}

			for (int i = 0; i < 884; i++)
			{
				gxr_awb.awb_output.final_lsc[i] = 1.0f;
			}

			gxr_awb.awb_output.wbgain.r_gain = 517;
			gxr_awb.awb_output.wbgain.g_gain = 256;
			gxr_awb.awb_output.wbgain.b_gain = 414;

			printf("[alAWBLib] CT: %3d\r\n", (int)gxr_awb.awb_output.color_temp);
			printf("[alAWBLib] WB Gain %3d %3d %3d\r\n", gxr_awb.awb_output.wbgain.r_gain, gxr_awb.awb_output.wbgain.g_gain, gxr_awb.awb_output.wbgain.b_gain);
			printf("[alAWBLib] CCM %3f %3f %3f\r\n", gxr_awb.awb_output.final_CCM[0], gxr_awb.awb_output.final_CCM[1], gxr_awb.awb_output.final_CCM[2]);
			printf("[alAWBLib] final_lsc %3f %3f \r\n", gxr_awb.awb_output.final_lsc[13 * 17], gxr_awb.awb_output.final_lsc[3 * 13 * 17 - 1]);

			//ispinput <- 2a
			wbgain[0] = gxr_awb.awb_output.wbgain.r_gain / 100.0f;
			wbgain[1] = gxr_awb.awb_output.wbgain.g_gain / 100.0f;
			wbgain[2] = gxr_awb.awb_output.wbgain.g_gain / 100.0f;
			wbgain[3] = gxr_awb.awb_output.wbgain.b_gain / 100.0f;
			memcpy(raw2bgr_handle->wbgain, wbgain, sizeof(wbgain));
			memcpy(raw2bgr_handle->ccm, gxr_awb.awb_output.final_CCM, sizeof(gxr_awb.awb_output.final_CCM));
			raw2bgr_handle->lsctable[0] = gxr_awb.awb_output.final_lsc;
			raw2bgr_handle->lsctable[1] = gxr_awb.awb_output.final_lsc + lsc_height * lsc_width;
			raw2bgr_handle->lsctable[2] = gxr_awb.awb_output.final_lsc + lsc_height * lsc_width * 2;
			raw2bgr_handle->lsctable[3] = gxr_awb.awb_output.final_lsc + lsc_height * lsc_width * 3;


			gxr_sraw2bgr_run_all(raw2bgr_handle);
			char ppmtemp[300];
			string ppmName;
			ppmName = path1 + "\\ppm\\";
			sprintf(ppmtemp, "%scam%d_%d.ppm", ppmName.c_str(), gxr_ae.cameraId, filecount);
			ppmWrite(ppmtemp, output_buffer, height, width);
			printf("debug saveppm\n");



			//if (filecount % 3 == 0)
			//{
			//    allConverge[gxr_ae.cameraId] = gxr_ae.ae_converged;
			//    actualexposure[gxr_ae.cameraId] = gxr_ae.ae_shutter * ae_sensor_gain * 100;
			//    
			//    sensorgain = ae_sensor_gain;
			//    shutter = gxr_ae.ae_shutter;
			//    ispgain = ae_out_ispgain;
			//    
			//}

			vector<float> expoInit;
			expoInit.push_back(gxr_ae.ae_shutter); //init exptime
			expoInit.push_back(ae_sensor_gain);  //init adgain
			expoInit.push_back(ae_out_ispgain);  //init ispgain
			expoInit.push_back(filecount * 1.0f);    //sofid
			expousureList.push(expoInit);

			vector<float> expoSOF;
			expoSOF = expousureList.front();
			expousureList.pop();
			allConverge[gxr_ae.cameraId] = gxr_ae.ae_converged;
			actualexposure[gxr_ae.cameraId] = expoSOF[0] * expoSOF[1] * 100;

			sensorgain = expoSOF[1];
			shutter = expoSOF[0];
			ispgain = expoSOF[2];

			printf("debug expsof  shutter %f  sensorgain %f ispgain %f", expoSOF[0], expoSOF[1], expoSOF[2]);

			printf("debug converge %d\n", allConverge[0]);

			printf("-----------------------end ------------------------------");

			free(input_buffer);
			free(crop_input_buffer);

			filecount++;
			fileCountinNum++;

			printf("debug converge %d\n", allConverge[1]);

			printf("-----------------------end ------------------------------");
			printf("\n debug sumtime %d", sumtime);
		} while (filecount < 200); //while (!allConverge[0] || !allConverge[1]);    //_findnext() intptr_t notlong

	}



	/*while (frame_num++ < 20 && allraw == 0)
	{
		//FILE* fid = fopen("0.raw", "rb");
		//FILE* fid = fopen("D:\\work\\AE\\data\\4l\\7ms_8x\\CAM1_[0]_[2328_1744]_[152110_0435]_10619.raw", "rb");
		//FILE* fid = fopen("D:\\work\\AE\\data\\4l\\7ms_8x\\CAM1_[0]_[2328_1744]_[152110_0435]_10619.raw", "rb");
		FILE* fid = fopen("D:\\CAM2hand\\testWdrChar\\target48\\CAM2_[25666]_[1164_872]_Shut[1623]_SenG[1.000]_IspG[1.000]_MidG[500]_ShaG[100]_BV[3882]_RG[0.463]_BG[0.585]_CT[4716].raw", "rb");
		fread(input_buffer, sizeof(unsigned short), height * width, fid);
		fclose(fid);

		//FOR AE NEED
		// get raw data ae param from sensor or get from ae out : ae_shutter \ ae_sensor_gain \ae_out_ispgain (must keep frame sync)
		// shutter =   
		// sensorgain =  
		//ispgain =			//update with ae out while match sensor param

		//update some isp intput param every frame 
		raw2bgr_handle->sensorgain = sensorgain;
		raw2bgr_handle->ispgain = ispgain;
		raw2bgr_handle->adrcgain = adrcgain;
		raw2bgr_handle->shutter = shutter;

		// stats to 2a
		gxr_sraw2bgr_run_all(raw2bgr_handle);
		memcpy(awbstats.data(), raw2bgr_handle->handle[2], awb_blknumx * awb_blknumy * 5 * sizeof(int));
		memcpy(aestats.data(), raw2bgr_handle->handle[3], ae_blknumx * ae_blknumy * 8 * sizeof(int));
		memcpy(histgram.data(), raw2bgr_handle->handle[4], 256 * sizeof(int));
		memcpy(atfstats.data(), raw2bgr_handle->handle[5], atf_roiheight * sizeof(int));

		// update aeinfo perframe
		gxr_ae.frameId = frame_num;
		gxr_ae.statsBankNum = ae_blknumy;
		gxr_ae.statsBolckNum = ae_blknumx;
		gxr_ae.ae_stats = aestats.data();			//get from isp aestats
		gxr_ae.yhis_stats = histgram.data();		// get from isp yhis
		gxr_ae.sensorgain = (int)sensorgain * 100;  //scale 
		gxr_ae.shutter = (int)shutter;
		gxr_ae.atf_mode = (int)ANTIFLICKER_OFF;  // DEFAULT OFF; OR GET FROM ATF  ANTIFLICKER_50HZ
		gxr_ae.debug_level = Debug;   //default: Log_OFF = 0
		//gxr_ae.debug_level = Log_OFF;   //default: Log_OFF = 0
		gxr_ae.save_to_file = true;
		gxr_ae.tuning_enable = 1;

		ae_err = ae_run(&gxr_ae);
		if (ae_err != 0x00) {
			printf("AE run error: %#x\r\n", ae_err);
			return ae_err;
		}

		// get ae out and save //write ae out to sensor and ispgain update while ae sensor  param effect
		ae_shutter     = (float)gxr_ae.ae_shutter;
		ae_sensor_gain = min(gxr_ae.ae_adgain / 100.0f, 16.0f);   //ae out has scale 100
		ae_out_ispgain = (float)max(1.0, gxr_ae.ae_adgain / 16 / 100.0);  //sensor adgain max is 16
		ae_lux_result  = gxr_ae.ae_lux_result / 1000.0f;  // lv scale 1000

		//update lux_index to isp current frame
		raw2bgr_handle->luxindex = ae_lux_result;

		// ATF
		gxr_atf.atf_stats = atfstats.data();
		gxr_atf.gain = sensorgain * 100;
		gxr_atf.exposure_time = shutter;
		//gxr_atf.average_value = gxr_ae.Ymean;
		gxr_atf.average_value = 3825;
		atf_err = atf_run(&gxr_atf);
		if (atf_err != 0x00) {
			printf("AFD run error: %#x\r\n", atf_err);
			return atf_err;
		}
		printf("[%02d] [alAFDLib] output result => flag_enable : %d, flag_bending : %d, afd_mode : %d, afd_mode_stable : %d\n",
			frame_num, gxr_atf.atf_output.flag_enable, gxr_atf.atf_output.flag_bending, gxr_atf.atf_output.atf_mode, gxr_atf.atf_output.atf_mode_stable);

		//update awbstats
		gxr_awb.awb_stats = awbstats.data();
		//for (int i = 0; i < 1000; i++) {
		//	printf("AWB stats %#d\r\n", awbstats[i]);
		//}

		//update awbinfo from ae
		gxr_awb.awb_set_para.type = ALAWB_SET_PARAM_UPDATE_AE_REPORT;
		gxr_awb.awb_set_para.para.ae_report_update.bv = gxr_ae.nextbv;
		gxr_awb.awb_set_para.para.ae_report_update.non_comp_bv = gxr_ae.bgbv;
		gxr_awb.awb_set_para.para.ae_report_update.iso = gxr_ae.iso;
		gxr_awb.awb_set_para.para.ae_report_update.midtones_gain = gxr_ae.midtones_gain;
		gxr_awb.awb_set_para.para.ae_report_update.shadows_gain = gxr_ae.shadows_gain;


		gxr_awb.debug_level = AWBDebug;   //default: Log_OFF = 0
		//gxr_ae.debug_level = Log_OFF;   //default: Log_OFF = 0
		gxr_awb.save_to_file = 1;
		awb_err = awb_run(&gxr_awb);
		if (awb_err != _AL_AWBLIB_SUCCESS) {
			printf("RUN ERROR %x\r\n", (unsigned int)awb_err);
			return awb_err;
		}
		printf("[alAWBLib] CT: %3d\r\n", (int)gxr_awb.awb_output.color_temp);
		printf("[alAWBLib] WB Gain %3d %3d %3d\r\n", gxr_awb.awb_output.wbgain.r_gain, gxr_awb.awb_output.wbgain.g_gain, gxr_awb.awb_output.wbgain.b_gain);
		printf("[alAWBLib] CCM %3f %3f %3f\r\n", gxr_awb.awb_output.final_CCM[0], gxr_awb.awb_output.final_CCM[1], gxr_awb.awb_output.final_CCM[2]);
		printf("[alAWBLib] final_lsc %3f %3f \r\n", gxr_awb.awb_output.final_lsc[13 * 17], gxr_awb.awb_output.final_lsc[3 * 13 * 17 - 1]);

		//update 2a to isp
		wbgain[0] = gxr_awb.awb_output.wbgain.r_gain / 100.0f;
		wbgain[1] = gxr_awb.awb_output.wbgain.g_gain / 100.0f;
		wbgain[2] = gxr_awb.awb_output.wbgain.g_gain / 100.0f;
		wbgain[3] = gxr_awb.awb_output.wbgain.b_gain / 100.0f;
		memcpy(raw2bgr_handle->wbgain, wbgain, sizeof(wbgain));
		memcpy(raw2bgr_handle->ccm, gxr_awb.awb_output.final_CCM, sizeof(gxr_awb.awb_output.final_CCM));
		raw2bgr_handle->lsctable[0] = gxr_awb.awb_output.final_lsc;
		raw2bgr_handle->lsctable[1] = gxr_awb.awb_output.final_lsc + lsc_height * lsc_width;
		raw2bgr_handle->lsctable[2] = gxr_awb.awb_output.final_lsc + lsc_height * lsc_width * 2;
		raw2bgr_handle->lsctable[3] = gxr_awb.awb_output.final_lsc + lsc_height * lsc_width * 3;

		gxr_sraw2bgr_run_all(raw2bgr_handle);

		ppmWrite("0.ppm", output_buffer, height, width);
	}
*/
	atf_err = atf_deinit(&gxr_atf);
	if (atf_err != 0x00) {
		printf("atf deinit error\r\n");
		return atf_err;
	}

	ae_err = ae_deinit(&gxr_ae);
	//ae_err = ae_deinit(&gxr_ae_c2);
	if (ae_err != 0x00) {
		printf("AE deinit error: %#x\r\n", ae_err);
		return ae_err;
	}

	awb_err = awb_deinit(&gxr_awb);
	if (awb_err != _AL_AWBLIB_SUCCESS) {
		printf("DEINIT ERROR %x\r\n", (unsigned int)awb_err);
		return awb_err;
	}

	gxr_sraw2bgr_release(raw2bgr_handle);
	delete raw2bgr_handle;
	//free(input_buffer);
	free(output_buffer);
	return 0;
}